---
title: "DE of Ibrutinib vs Duvelisib, pre-processed with STAR + HTSeq"
author: "Caroline Lohoff"
date: "May 16 2022"
output:
  BiocStyle::html_document:
    toc_float: true
---

# Description

In this differential gene expression analysis we compare the gene expression between samples treated with Ibrutinib and Duvelisib.
Since Duvelisib has more differentially expressed genes compared to Ibrutinib with DMSO as reference and also a stronger impact on cell viability, we expect that Duvelisib deregulates more pathways than Ibrutinib. Therefore, we conduct a pairwise t-test and compare Duvelisib vs Ibrutinib, i.e. Ibrutinib is the reference. 

Design formula: ~ patID + condition  (Duv vs Ibr)

# Load libraries and set options

Set global options
```{r setup, include=FALSE, cache = FALSE}
knitr::opts_knit$set(root.dir = "~/Documents/R/drugseq_test")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

Load libraries
```{r}
suppressPackageStartupMessages({
  
   #Main libraries
  library(DESeq2)
  library(tidyverse)
  library(clusterProfiler)
  library(pathview)
  library(pheatmap)
  library(enrichplot)
  library(progeny)
  library(dorothea)
  library(decoupleR)
  library(CARNIVAL)
  library(OmnipathR)
  library(visNetwork)
  library(viper)

  # Support libraries
  library(RColorBrewer)
  library(cowplot)
  library(gridExtra)
  library(grid)
  library(ggrepel)
  library(hexbin) 
  library(reshape)
  library(vsn)
  library(org.Hs.eg.db)
  library(annotate)
  library(ReactomePA)
  library(BiocParallel)
})
register(MulticoreParam(2))
```

Set global ggplot variables
```{r}
theme_set(theme_bw() + theme(axis.text = element_text(size=12), 
                             axis.title = element_text(size=14),
                             legend.title = element_text(size=14),
                             legend.text = element_text(size=12),
                             plot.title = element_text(size=16,
                                                       hjust=0.5,face="bold")))
```

# Load data and add annotations
```{r}
# Load dds data set containing 1106 samples and count matrix
load("./output/ddsDrug_htseq_batchPilot1c234_20220426.RData")

# Load meta data including genotyping info
load("./data/patmeta_210324.RData")

# Add columns to DESeq object using patient meta data
col_vec <- c("diagnosis", "gender", "Methylation_Cluster", "trisomy12", "NOTCH1", "TP53")
ddsDrug@colData@listData <- lapply(col_vec, function(n) {
  ddsDrug[[n]] <- patMeta[match(ddsDrug$patID, patMeta$Patient.ID), n]
}) %>% bind_cols() %>% sjmisc::add_columns(ddsDrug@colData@listData)

names(ddsDrug@colData@listData)[names(ddsDrug@colData@listData) == "Methylation_Cluster"] <- "Methylation"
ddsDrug$IGHVpat <- patMeta[match(ddsDrug$patID, patMeta$Patient.ID),]$IGHV.status
ddsDrug$IGHV <- ifelse(is.na(ddsDrug$IGHV), ddsDrug$IGHVpat, ddsDrug$IGHV)

# Add meta data to the samples from the pilot batch
ddsDrug$diagnosis[ddsDrug$batch == "pilot"] <- "CLL" 
ddsDrug$trisomy12[ddsDrug$batch == "pilot"] <- 0
ddsDrug$NOTCH1[ddsDrug$batch == "pilot"] <- 0
ddsDrug$TP53[ddsDrug$batch == "pilot"] <- 0
ddsDrug$IGHV[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1095", "PID1222")] <- "U"
ddsDrug$IGHV[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1177", "PID1210")] <- "M"
ddsDrug$gender[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1095", "PID1222")] <- "f"
ddsDrug$gender[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1177", "PID1210")] <- "m"

# Rename IGHV status from 'U' and 'M' to 0 and 1
ddsDrug$IGHV[ddsDrug$IGHV == "U"] <- 0
ddsDrug$IGHV[ddsDrug$IGHV == "M"] <- 1
ddsDrug$IGHV <- as.factor(ddsDrug$IGHV)
ddsDrug$IGHVpat <- NULL

# Replace spaces in treatment names
ddsDrug$treatment <- str_replace_all(ddsDrug$treatment,"[- ]","_")

dim(ddsDrug)
```

Filter patients
```{r}
# Remove patients with a low mapping rate & little counts
remPat <- c("P0437", "P0738", "P0029")
ddsAll <- ddsDrug[, !ddsDrug$patID %in% remPat]

# Keep only CLL patients and remove Jurkat samples
ddsAll <- ddsAll[,ddsAll$diagnosis == "CLL" &
                   ddsAll$treatment != "Baseline" &
                   ddsAll$Replicate == 1]
dim(ddsAll)
```

Filter genes by their counts and type
```{r}
# Only use protein coding genes and remove genes with unknown gene symbol
ddsAll <- ddsAll[rowData(ddsAll)$biotype == "protein_coding" & !rowData(ddsAll)$symbol %in% c(NA, ""),]

# Remove genes on Y chromosome, mitochondrial and artificial chromosomes
ddsAll <- ddsAll[rowData(ddsAll)$chromosome %in% c(1:22,"X")]
table(rowData(ddsAll)$chromosome)

# Keep only genes with a minimum of 10 counts in any sample
keep_counts <- apply(counts(ddsAll), 1, function(x) any(x >= 10))
ddsAll <- ddsAll[keep_counts,]

# Keep only genes expressed in at least 30% of all samples, 
# since most genes have a basal expression. 
# With this function the sparsity of the expression matrix is reduced.
expr_min <- round(ncol(counts(ddsAll)) * 0.7)
keep_counts_expr <- apply(counts(ddsAll), 1, function(x) sum(x == 0) < expr_min)
ddsAll <- ddsAll[keep_counts_expr,]

dim(ddsAll)
```


# Differential expression using DESeq2

Differential expression analysis of genomic data types uses linear models to determine the size and direction of the changes in gene expression.

## Preparations of input data

### Correct count matrix with scTransform
(Resulting counts are integers and can be used as input for DESeq2)
```{r, results=FALSE}
countMat <- counts(ddsAll)
scModel <- sctransform::vst(countMat,
                            return_corrected_umi = TRUE)

# Extract normalized counts matrix
countMat.norm <- as.matrix(scModel$umi_corrected)

# Create new ddsAll object with norm. counts matrix and colData from ddsDrug
ddsAll.adj <- DESeqDataSetFromMatrix(countMat.norm,
                                     colData = colData(ddsAll), design = ~1)
rowData(ddsAll.adj) <- rowData(ddsAll[rownames(countMat.norm)],)

# Reset size factors
ddsAll.adj$sizeFactor <- 1
```

Subset dds object and keep only Ibrutinib and Duvelisib samples
```{r}
allTreat <- c("Ibrutinib", "Duvelisib")

patIDIbr <- unique(ddsAll.adj$patID[ddsAll.adj$treatment == "Ibrutinib"])
patIDDuv <- unique(ddsAll.adj$patID[ddsAll.adj$treatment == "Duvelisib"])
keepPat <- intersect(patIDIbr, patIDDuv)
ddsTr <- ddsAll.adj[, ddsAll.adj$treatment %in% allTreat &
                      ddsAll.adj$patID %in% keepPat]
dim(ddsTr)
```

Add design to dds objects
```{r}
ddsTr$condi <- factor(ddsTr$treatment)
ddsTr$condi <- factor(ddsTr$condi,
                       levels = c("Ibrutinib",setdiff(levels(ddsTr$condi),c("Ibrutinib"))))
ddsTr$patID <- factor(ddsTr$patID)
design(ddsTr) <- ~ patID + condi

# Extract patient annotations
patAnno <- as.data.frame(colData(ddsTr))
```

## Run DESeq2

The DESeq function fits the raw counts to the negative binomial model. The final dds object contains all the information needed for performing DE testing between specific sample groups. New information such as shrunken dispersions, model coefficients, Wald test results, and gene-wise dispersions will be added to the dds object.
```{r, eval=FALSE}
ddsTrDis <- estimateDispersions(ddsTr)
DEres <- nbinomWaldTest(ddsTrDis, maxit=2000)
save(DEres, file = "./output/DEres_allbatches_STAR_patIDcondi_DuvvsIbr_scTransform_20220516.RData")
```

## Load results

Get results
```{r}
load("./output/DEres_allbatches_STAR_patIDcondi_DuvvsIbr_scTransform_20220516.RData")
```

Omit any remaining gene rows, as these are typically genes with very small counts and little power
```{r}
DEresClean <- DEres[which(mcols(DEres)$betaConv),]
```
Furthermore, one could examine the counts for the rows that are not converging. Often, these genes have problematic distribution of counts, e.g. they contain outliers. If the rows do not represent DE genes, their p-values and adj p-values could be set to NA.

Extract results names
```{r}
#resultsNames(DEresClean)
```

Extract data frame before shrinkage of LFCs
```{r}
resTabc <- results(DEresClean, 
                    name = "condi_Duvelisib_vs_Ibrutinib",
                    tidy = TRUE)
names(resTabc)[names(resTabc) == "row"] <- "Ensembl"
names(resTabc)[names(resTabc) == "log2FoldChange"] <- "LFC"
resTabc <- resTabc %>%
  mutate(symbol = rowData(ddsDrug)[Ensembl,]$symbol,
         chromosome = rowData(ddsDrug)[Ensembl,]$chromosome)
resTabc <- resTabc[,c(1,8,9,2,3,4,5,6,7)]
# almost one third of the genes has no adjusted p-value
```

### Log fold change shrinkage
Shrinkage of effect size (LFC estimates) is useful for visualization and ranking of genes. 

The results for each treatment are extracted with prior shrinkage of LFC values using the [apeglm estimator](https://academic.oup.com/bioinformatics/article/35/12/2084/5159452), which improves on the previous estimator.
Before applying the lfcShrink function, we omit the rows which did not converge. 
```{r, eval=FALSE}
res <- lfcShrink(DEresClean, coef="condi_Duvelisib_vs_Ibrutinib",
                 type="apeglm", parallel=TRUE)
save(res, file = "./output/DEresShrink_allbatches_STAR_patIDcondi_DuvvsIbr_scTransform_20220516.RData")
```

Load data with shrunken LFCs
```{r}
load("./output/DEresShrink_allbatches_STAR_patIDcondi_DuvvsIbr_scTransform_20220516.RData")
```

Extract data frame
```{r}
resTab <- data.frame(res@listData) %>%
      rownames_to_column(var = "Ensembl") %>%
      mutate(symbol = rowData(ddsDrug)[Ensembl,]$symbol) %>%
      mutate(chromosome = rowData(ddsDrug)[Ensembl,]$chromosome)
names(resTab)[names(resTab) == "log2FoldChange"] <- "LFC"
resTab <- resTab[,c(1,7,8,2,3,4,5,6)]
# almost one third of the genes has no adjusted p-value
```

Save data frame as csv file
```{r, eval=FALSE}
write.csv(resTab, file="./output/Resdf_DuvvsIbr_STAR_scTransform_20220516.csv")
save(resTab, file = "./output/Resdf_DuvvsIbr_STAR_scTransform_20220516.RData")
```

View data frame
```{r}
resTab %>%
  dplyr::select(Ensembl, symbol, chromosome,
                LFC, pvalue, padj) %>%
  arrange(padj) %>%
  mutate_if(is.numeric, formatC, digits=2) %>%
  DT::datatable()
```


# Visualize DE results

In this section we explore how well our data fit the model.

## Dispersion of results before shrinkage
```{r}
plotDispEsts(DEresClean)
```
The dispersion estimate looks quite good. 

### Distribution of LFCs

The function plotMA shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the data set. Points will be colored red if the adjusted p value is less than 0.1. Points which fall out of the window are plotted as open triangles pointing either up or down.
```{r}
plotMA(DEres, ylim=c(-1.5,1.5), alpha=0.25,
       main="Duvelisib vs Ibrutinib (before shrinkage)")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
abline(h=c(-0.5,0.5), col="lightblue", lwd=2)
```

```{r}
plotMA(res, ylim=c(-1.5,1.5), alpha=0.25,
       cex=.8, main="Duvelisib vs Ibrutinib (after shrinkage)")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
abline(h=c(-0.5,0.5), col="lightblue", lwd=2)
```
After shrinkage, the log-fold change values are quite small. Not many genes are differentially expressed in Duvelisib in comparison to Ibrutinib.

## P-value histogram

```{r}
ggplot(resTab, aes(x=pvalue)) +
  geom_histogram(fill="lightblue", color="black", binwidth=0.025) +
  geom_vline(xintercept=0.05,color="red",linetype="longdash") +
  scale_x_continuous(breaks = seq(0,1,by=0.1)) +
  ylab("# of genes") +
  theme(plot.title = element_text(face="bold",hjust=0.5))
```
The p-value histogram looks very good, as there is a uniform background distribution and on top a peak on the left side, which indicates the number of genes considered as significant (p-value below 0.1).

## Number of significant DE genes 

When looking at the p-value histograms, one would like to know how many genes pass a certain p-value cutoff. In the p-value histograms the cutoff is indicated at 0.05 (5% FDR). The barplots below answer the question, how many genes have a smaller adjusted p-value then 0.05, 0.1 and 0.25? 

### Preparation

Function for creating a df with significant up- or downregulated genes
```{r}
sig_genes_df <- function(fdr, lfc){
  
  # Create new df with number of sig. genes for each treatment
  genes_df <- setNames(data.frame(matrix(ncol = 2, nrow = 0)),
                         c("direction", "sig_genes"))
  
  # Extract upregulated genes
  genes_up <- resTab %>%
    filter(LFC >= lfc & padj < fdr) %>%
    summarise(n=length(Ensembl)) %>% pull(n)
  # Add new row to df
  new_row <- c("up", genes_up)
  genes_df[nrow(genes_df) + 1, ] <- new_row
  
  # Extract downregulated genes
  genes_down <- resTab %>%
    filter(LFC <= -lfc & padj < fdr) %>%
    summarise(n=length(Ensembl)) %>% pull(n)
  # Add new row to df
  new_row <- c("down", genes_down)
  genes_df[nrow(genes_df) + 1, ] <- new_row
  
  # Operations on columns of new df
  genes_df$sig_genes <- as.numeric(genes_df$sig_genes)
  genes_df$direction <- factor(genes_df$direction,
                               levels = c("up", "down"))
  return(genes_df)
}
```

Function for plotting number of significant genes
```{r}
sigDEgenes <- function(df, title){
  plot <- ggplot(df, aes(x=direction, y=sig_genes)) +
    geom_bar(stat = "identity", color="black", fill="#0C3C9F") +
    ylab("# significant DE genes") +
    theme(axis.title.x = element_blank()) +
    ggtitle(title) +
    geom_text(aes(label=sig_genes),vjust=1.2,size=5, color="white")
  return(plot)
}
```

Create plots
```{r,fig.height=9, fig.width=10}
# 5% FDR
df <- sig_genes_df(fdr=0.05, lfc=0)
df_5F_0L <- sigDEgenes(df,"5% FDR with LFC = 0")

# 10% FDR
df <- sig_genes_df(fdr=0.1, lfc=0)
df_10F_0L <- sigDEgenes(df,"10% FDR with LFC = 0")

# 25% FDR
df <- sig_genes_df(fdr=0.25, lfc=0)
df_25F_0L <- sigDEgenes(df,"25% FDR with LFC = 0")

# 5% FDR
df <- sig_genes_df(fdr=0.05, lfc=0.05)
df_5F_05L <- sigDEgenes(df,"5% FDR with LFC = 0.05")

# 10% FDR
df <- sig_genes_df(fdr=0.1, lfc=0.05)
df_10F_05L <- sigDEgenes(df,"10% FDR with LFC = 0.05")

# 25% FDR
df <- sig_genes_df(fdr=0.25, lfc=0.05)
df_25F_05L <- sigDEgenes(df,"25% FDR with LFC = 0.05")

# 5% FDR
df <- sig_genes_df(fdr=0.05, lfc=0.2)
df_5F_2L <- sigDEgenes(df,"5% FDR with LFC = 0.2")

# 10% FDR
df <- sig_genes_df(fdr=0.1, lfc=0.2)
df_10F_2L <- sigDEgenes(df,"10% FDR with LFC = 0.2")

# 25% FDR
df <- sig_genes_df(fdr=0.25, lfc=0.2)
df_25F_2L <- sigDEgenes(df,"25% FDR with LFC = 0.2")

# 5% FDR
df <- sig_genes_df(fdr=0.05, lfc=0.5)
df_5F_5L <- sigDEgenes(df,"5% FDR with LFC = 0.5")

# 10% FDR
df <- sig_genes_df(fdr=0.1, lfc=0.5)
df_10F_5L <- sigDEgenes(df,"10% FDR with LFC = 0.5")

# 25% FDR
df <- sig_genes_df(fdr=0.25, lfc=0.5)
df_25F_5L <- sigDEgenes(df,"25% FDR with LFC = 0.5")

plot_grid(df_5F_0L, df_10F_0L, df_25F_0L, df_5F_05L,
          df_10F_05L, df_25F_05L, df_5F_2L, df_10F_2L,
          df_25F_2L, df_5F_5L, df_10F_5L, df_25F_5L, ncol=3)
```

## Volcano plot

Remove genes with non-calculated adjusted p-values
```{r}
resTabna <- resTab[!is.na(resTab$padj),]
resTabnac <- resTabc[!is.na(resTabc$padj),]
```

Show volcano plot
```{r, fig.height=7, fig.width=12}
create_volcano <- function(df, title){
  plot <- ggplot(df, aes(x=LFC, y=-log10(padj))) +
    geom_vline(xintercept = 0, color="black", linetype="solid", size=0.25) +
    geom_vline(xintercept = 0.5, color="darkgrey", linetype="dashed") +
    geom_vline(xintercept =-0.5, color="darkgrey", linetype="dashed") +
    geom_hline(yintercept = -log10(0.05), color="darkgrey", linetype="dashed") +
    annotate(x=-0.8, y=1.6, label=paste("p-adjusted = ", 0.05), geom="text", size=3, color="darkgrey") +
    geom_hline(yintercept = -log10(0.25), color="darkgrey", linetype="dashed") +
    annotate(x=-0.8, y=0.9, label=paste("p-adjusted = ", 0.25), geom="text", size=3, color="darkgrey") +
    geom_point(data=df[df$LFC >= 0 & df$padj <= 0.25,],
              color="firebrick3", size=0.9) +
    geom_point(data=df[df$LFC <= 0 & df$padj <= 0.25,],
              color="navy", size=0.9) +
    geom_point(data=df[df$padj >= 0.25,], color="darkgrey", size=0.9) +
    ggrepel::geom_label_repel(data=df[df$LFC > 0 & df$padj <= 0.01,],
                              aes(label=symbol), color="firebrick3", size=2,
                              max.overlaps=15) +
    ggrepel::geom_label_repel(data=df[df$LFC < 0 & df$padj <= 0.01,],
                              aes(label=symbol), color="navy", size=2,
                              max.overlaps=15) +
    ggtitle(title) +
    theme(plot.title = element_text(hjust=0.5, face="bold"))
  return(plot)
}

v1 <- create_volcano(resTabnac, "Before LFC shrinkage")
v2 <- create_volcano(resTabna, "After LFC shrinkage")
plot_grid(v1, v2, ncol=2)
```
We have to use a very low LFC cutoff for the pathway enrichment. 


# Pathway Enrichment Analysis

For the pathway enrichment analysis the genes considered as differentially expressed between Duvelisib and Ibrutinib with an adjusted p-value below 0.25 and a log-fold change larger than 0.05 are used as input. These criteria were chosen based on the plots above. Being more strict leads to a list of DE genes which might be to short for finding gene sets. 
```{r}
padjusted <- 0.25
lfc <- 0.05

# Filter data frame
gene_list_df <- resTab %>%
  dplyr::filter(padj <= padjusted,
         LFC > lfc | LFC < -lfc) %>%
  dplyr::select(Ensembl, symbol, padj)
gene_list_df$treatment <- "Duvelisib"

# Number of genes used for pathway enrichment
n_genes <- pull(gene_list_df, Ensembl)
length(n_genes)
```

## clusterProfiler
clusterProfiler is a universal enrichment tool for interpreting omics data and supports several ontology and pathway annotations.
[ClusterProfiler 4.0](https://doi.org/10.1016/j.xinn.2021.100141) was expanded for conducting biological theme comparison. 
The provided function "compareCluster" calculates enriched functional profiles of each gene cluster and aggregates the results into a single object. Therefore, we can analyze the effects of all treatments at once. The disadvantage of "compareCluster" is that it can only perform over-representation analyses and not gene set enrichment analyses.

Perpare gene lists as data frames
```{r prepare-cP}
# Convert Ensembl IDs to Entrez IDs
EntrezID = mapIds(org.Hs.eg.db,
                  keys=gene_list_df$Ensembl,
                  column="ENTREZID",
                  keytype="ENSEMBL",
                  multiVals="first")

# Add EntredID column to df
cluster_df <- add_column(gene_list_df, EntrezID, .before = "symbol")
cluster_df <- cluster_df[!is.na(cluster_df$EntrezID),]
```

### ORA with “compareCluster” function and GO pathways

In this analysis we use pathways from gene ontology.
```{r}
clusterResGO <- compareCluster(EntrezID~treatment, data=cluster_df, fun="enrichGO",
                               OrgDb=org.Hs.eg.db, pvalueCutoff=0.25, pAdjustMethod="BH")
```

Each column in the dotplot represents an enrichment result of a treatment. The color gradient based on p-values may indicate which categories are more likely to have biological meanings. The size of the dots refers to the number of genes considered as significant within a pathway.
```{r, fig.height=5, fig.width=6}
dotplot(clusterResGO, showCategory=10, size="Count",
        title="Enriched GO Pathways after ORA")
```

### ORA with “compareCluster” function and Reactome pathways

In this analysis we use pathways from Reactome, an open-source, manually curated and peer-reviewed pathway database.
```{r}
clusterResReactome <- compareCluster(EntrezID~treatment, data=cluster_df,
                                     fun="enrichPathway", pvalueCutoff=0.25, pAdjustMethod="BH")
```

Dotplot
```{r, fig.height=7, fig.width=6}
dotplot(clusterResReactome, showCategory=10, size="Count",
        title="Enriched Reactome Pathways after ORA")
```

### GSEA with "gseKEGG" function
If we want to conduct a gene set enrichment analysis (GSEA) instead of an over-representation analysis, we have to use the "gseKEGG" function.

Prepare gene list
```{r}
# Extract sorted gene list
cluster_dforder <- cluster_df[order(cluster_df$padj, decreasing=TRUE),]
geneList <- cluster_dforder$padj
names(geneList) <- cluster_dforder$EntrezID
```


#### KEGG pathways

Run gseKEGG function
```{r}
gseKEGG_res <- gseKEGG(geneList=geneList, organism="hsa",
                       minGSSize=5, maxGSSize=800,
                       pvalueCutoff=0.9, pAdjustMethod="BH",
                       scoreType="pos", keyType="kegg")
```

```{r}
gseKEGG_resNoAdj <- gseKEGG(geneList=geneList, organism="hsa",
                       minGSSize=5, maxGSSize=800,
                       pvalueCutoff=0.5, pAdjustMethod="none",
                       scoreType="pos", keyType="kegg")
```

Dotplot
```{r}
dotplot(gseKEGG_resNoAdj, showCategory=10, title="Enriched KEGG Pathways",
        size="Count", split=".sign") + facet_grid(.~.sign)
```

Enrichment map organizes enriched terms into a network with edges connecting overlapping gene sets. In this way, mutually overlapping gene sets are tend to cluster together, making it easy to identify functional modules.
```{r}
map <- pairwise_termsim(gseKEGG_resNoAdj)
emapplot(map, showCategory=10)
```

The category netplot depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network (helpful to see which genes are involved in enriched pathways and genes that may belong to multiple annotation categories).
```{r}
cnetplot(gseKEGG_resNoAdj, categorySize="pvalue", foldChange=geneList)
```

A ridgeplot is hlpful to interpret up/down-regulated pathways.
```{r, fig.width=10, fig.height=16}
ridgeplot(gseKEGG_resNoAdj) +
  labs(x = "enrichment distribution")
```

Plots the number/proportion of publications trend of enriched pathways based on the query result from PubMed Central.
```{r, fig.width=8, fig.height=6}
library("europepmc")
terms <- gseKEGG_resNoAdj$Description[1:5]
pmcplot(terms, 2009:2021, proportion=FALSE)
```


```{r, eval=FALSE}
head(gseKEGG_resNoAdj,n=10)
```

Pathview plots
```{r}
# ErbB signaling pathway
dme <- pathview(gene.data=geneList, species="hsa",
                pathway.id="hsa04012")
knitr::include_graphics("hsa04012.pathview.png")

# Endocytosis
dme <- pathview(gene.data=geneList, species="hsa",
                pathway.id="hsa04144")
knitr::include_graphics("hsa04144.pathview.png")

# mRNA surveillance pathway
dme <- pathview(gene.data=geneList, species="hsa",
                pathway.id="hsa03015")
knitr::include_graphics("hsa03015.pathview.png")
```


## camera

This method was proposed by Wu and Smyth in 2012. [camera](https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/camera) performs a competitive test in the sense defined by [Goeman and Buhlmann](https://doi.org/10.1093/bioinformatics/btm051). It tests whether the genes in the set are highly ranked in terms of differential expression relative to genes not in the set and thereby accounts for inter-gene correlation. As input camera only needs a count matrix and a design matrix. No prior differential expression (DE) is required, as camera performs a DE internally. Again, we can perform a gene set enrichment analysis for every drug treatment individually.

### Preparations
First, we have to prepare the gene lists and create the design matrix.
```{r prepare-camera}
gmt_KEGG <- read.gmt("data/c2.cp.kegg.v7.4.symbols.gmt.txt")
gmt_Hallmark <- read.gmt("data/h.all.v7.4.symbols.gmt.txt")

#Function for converting gene name data frame into list
geneList <- function(source) {
  pathwayNames <- levels(source$term)
  newList<- vector("list")

  for (pathway in pathwayNames) {
    genes <- source$gene[source$term == pathway]
    newList[[length(newList) + 1]] <- genes 
  }
  names(newList) <- pathwayNames
  return(newList)
}

geneList_KEGG <- geneList(gmt_KEGG)
geneList_Hallmark <- geneList(gmt_Hallmark)
```

Function for converting Ensembl IDs to gene symbols
```{r}
convertIDs <- function(counts_df){

  # Convert Ensembl IDs to Entrez IDs
  entrezID = mapIds(org.Hs.eg.db,
                    keys=row.names(counts_df),
                    column="ENTREZID",
                    keytype="ENSEMBL",
                    multiVals="first")

  # Convert Entrez IDs to gene symbols
  gene_symbols <- getSYMBOL(na.omit(as.vector(entrezID)),
                            data="org.Hs.eg.db")

  # Create new df with gene symbols as row names
  counts_df_symbols <- add_column(counts_df, entrezID) %>%
    drop_na(entrezID) %>% add_column(gene_symbols) %>%
    dplyr::select(-entrezID) %>% drop_na(gene_symbols) %>%
    distinct(gene_symbols, .keep_all = TRUE) %>%
    remove_rownames %>% column_to_rownames(var="gene_symbols")
  
  return(counts_df_symbols)
}
```

```{r}
# Create design matrix
designMat <- model.matrix(~ patID + condi, patAnno)

# Extract normalized counts
ddsTr.vst <- vst(ddsTr)
countMatTr.vst <- assay(ddsTr.vst)
counts_dfTr.vst <- as.data.frame(assay(ddsTr.vst))

# Create counts_df with gene symbols
counts_dfTr.symb <- convertIDs(counts_dfTr.vst)
```

### Run camera

```{r}
# Run camera function with KEGG pathways
cameraRes_KEGG <- limma::camera(counts_dfTr.symb, geneList_KEGG,
                           designMat, inter.gene.cor=0.01)
cameraRes_KEGG <- rownames_to_column(cameraRes_KEGG,var="Pathway")

# Run camera function with Hallmark pathways
cameraRes_Hall <- limma::camera(counts_dfTr.symb, geneList_Hallmark,
                          designMat, inter.gene.cor=0.01)
cameraRes_Hall <- rownames_to_column(cameraRes_Hall,var="Pathway")
```

### Show results

Plot most important pathways for Duvelisib in comparison to Ibrutinib
```{r, fig.height=8, fig.width=14}
# Add information about total number of genes in pathways to calculate gene ratio
#cameraRes_kegg <- mapply(cbind, cameraRes_kegg, "TGenes"=lengths(geneList_kegg))

c1 <- cameraRes_KEGG[head(order(cameraRes_KEGG$FDR), 10), ] %>%
  ggplot(aes(x=Direction, y=reorder(Pathway, -FDR),
             group=Direction, col=FDR)) +
  geom_point(size=5) +
  ggtitle("KEGG pathways") +
  theme(axis.title=element_blank(),
        axis.text=element_text(face="bold")) +
  scale_colour_gradientn(colours=c("#FF0000", "#E90F97", "#0858FB"))

c2 <- cameraRes_Hall[head(order(cameraRes_Hall$FDR), 10), ] %>%
  ggplot(aes(x=Direction, y=reorder(Pathway, -FDR),
             group=Direction, col=FDR)) +
  geom_point(size=5) +
  ggtitle("Hallmark pathways") +
  theme(axis.title=element_blank(),
        axis.text=element_text(face="bold")) +
  scale_colour_gradientn(colours=c("#FF0000", "#E90F97", "#0858FB"))

plot_grid(c1, c2, ncol=2)
```


# Boxplots of most interesting genes

From the top 10 pathways, we extract the genes considered as differentially expressed between Duvelisib and Ibrutinib. 
To exclude genes for which more than 50% of the samples have an expression of 0 counts, we filter the median counts. Only genes with a median count larger than 0 in the samples treated with Duvelisib pass this criterion. 
Boxplots are used to vizualize wether a gene is downregulated in all Duvelisib samples compared to Ibrutinib. 

## Create mapping data frame for Ensembl IDs to symbols
```{r}
ddsAll.adjbeforevst <- ddsAll.adj
ddsAll.adj <- vst(ddsAll.adj)

nrow(ddsAll.adj)
df_geneIDs <- as.data.frame(rownames(assay(ddsAll.adj)))
colnames(df_geneIDs) <- "Ensembl"
df_geneIDs <- df_geneIDs %>%
  mutate(symbol = rowData(ddsDrug)[Ensembl,]$symbol)

# check for any duplicated gene symbols
duplicate_symbols <- which(duplicated(df_geneIDs$symbol))
df_geneIDs[rownames(df_geneIDs) == duplicate_symbols,]$symbol

# The duplicated row will be removed 
df_geneIDs <- df_geneIDs[-c(duplicate_symbols), ]
ddsAll.adj <- ddsAll.adj[!duplicated(rowData(ddsAll.adj)$symbol),]

nrow(ddsAll.adj)
```

As we are also interested in the IGHV status, we remove all patients with undefined IGHV status
```{r}
ncol(ddsAll.adj)
ddsAll.adj <- ddsAll.adj[,!is.na(ddsAll.adj$IGHV)]
ncol(ddsAll.adj)
```

## Extract counts matrices for DMSO, Ibrutinib, Duvelisib
Keep only genes with median counts > 0
```{r}
# Retrieve patients with samples for DMSO, Ibrutinib and Duvelisib
patIDDMSO <- unique(ddsAll.adj$patID[ddsAll.adj$treatment == "DMSO"])
patIDIbr <- unique(ddsAll.adj$patID[ddsAll.adj$treatment == "Ibrutinib"])
patIDDuv <- unique(ddsAll.adj$patID[ddsAll.adj$treatment == "Duvelisib"])
patIDall <- intersect(patIDDMSO, intersect(patIDIbr, patIDDuv))

# Extract dds objects containing only DMSO, Ibrutinib or Duvelisib samples
ddsDMSO <- ddsAll.adj[, ddsAll.adj$treatment == "DMSO" &
                        ddsAll.adj$patID %in% patIDall]
ddsIbr <- ddsAll.adj[, ddsAll.adj$treatment == "Ibrutinib" &
                       ddsAll.adj$patID %in% patIDall]
ddsDuv <- ddsAll.adj[, ddsAll.adj$treatment == "Duvelisib" &
                       ddsAll.adj$patID %in% patIDall]

# U-CLL
ddsDMSO_U <- ddsDMSO[,ddsDMSO$IGHV == 0]
counts_dfDMSO_U <- as.data.frame(assay(ddsDMSO_U))
colnames(counts_dfDMSO_U) <- ddsDMSO_U$patID
rownames(counts_dfDMSO_U) <- df_geneIDs$symbol
counts_dfDMSO_U$row_median <- matrixStats::rowMedians(as.matrix(counts_dfDMSO_U))
counts_dfDMSO_U <- counts_dfDMSO_U[counts_dfDMSO_U$row_median > 0,]

ddsIbr_U <- ddsIbr[,ddsIbr$IGHV == 0]
counts_dfIbr_U <- as.data.frame(assay(ddsIbr_U))
colnames(counts_dfIbr_U) <- ddsIbr_U$patID
rownames(counts_dfIbr_U) <- df_geneIDs$symbol
counts_dfIbr_U$row_median <- matrixStats::rowMedians(as.matrix(counts_dfIbr_U))
counts_dfIbr_U <- counts_dfIbr_U[counts_dfIbr_U$row_median > 0,]

ddsDuv_U <- ddsDuv[,ddsDuv$IGHV == 0]
counts_dfDuv_U <- as.data.frame(assay(ddsDuv_U))
colnames(counts_dfDuv_U) <- ddsDuv_U$patID
rownames(counts_dfDuv_U) <- df_geneIDs$symbol
counts_dfDuv_U$row_median <- matrixStats::rowMedians(as.matrix(counts_dfDuv_U))
counts_dfDuv_U <- counts_dfDuv_U[counts_dfDuv_U$row_median > 0,]

# M-CLL
ddsDMSO_M <- ddsDMSO[,ddsDMSO$IGHV == 1]
counts_dfDMSO_M <- as.data.frame(assay(ddsDMSO_M))
colnames(counts_dfDMSO_M) <- ddsDMSO_M$patID
rownames(counts_dfDMSO_M) <- df_geneIDs$symbol
counts_dfDMSO_M$row_median <- matrixStats::rowMedians(as.matrix(counts_dfDMSO_M))
counts_dfDMSO_M <- counts_dfDMSO_M[counts_dfDMSO_M$row_median > 0,]

ddsIbr_M <- ddsIbr[,ddsIbr$IGHV == 1]
counts_dfIbr_M <- as.data.frame(assay(ddsIbr_M))
colnames(counts_dfIbr_M) <- ddsIbr_M$patID
rownames(counts_dfIbr_M) <- df_geneIDs$symbol
counts_dfIbr_M$row_median <- matrixStats::rowMedians(as.matrix(counts_dfIbr_M))
counts_dfIbr_M <- counts_dfIbr_M[counts_dfIbr_M$row_median > 0,]

ddsDuv_M <- ddsDuv[,ddsDuv$IGHV == 1]
counts_dfDuv_M <- as.data.frame(assay(ddsDuv_M))
colnames(counts_dfDuv_M) <- ddsDuv_M$patID
rownames(counts_dfDuv_M) <- df_geneIDs$symbol
counts_dfDuv_M$row_median <- matrixStats::rowMedians(as.matrix(counts_dfDuv_M))
counts_dfDuv_M <- counts_dfDuv_M[counts_dfDuv_M$row_median > 0,]
```


## Extract DE genes from pathways of interest
Reactome pathways
```{r}
pathway_df_Reactome <- as.data.frame(clusterResReactome@compareClusterResult)

# Extract DE genes from top 10 pathways as gene symbol
gene_list_pathways <- lapply(seq_len(10), function(row) {
  
  # Extract Entrez IDs of all DE genes in one pathway
  genes_all <- pathway_df_Reactome$geneID[row]

  # Split strings
  genes <- unlist(strsplit(genes_all, "\\/"))
  
  # Map EntrezIDs to gene symbols (use input df for clusterProfiler)
  genes_symb <- cluster_df[cluster_df$EntrezID %in% genes,]$symbol
})

# Extract names of top 10 pathways
gene_names_pathways <- lapply(seq_len(10), function(row) {
  name <- pathway_df_Reactome$Description[row]
})
pathway_names <- unlist(gene_names_pathways)

# Add pathway names to gene lists
names(gene_list_pathways) <- pathway_names
```


## Create boxplots

Function to create new data frame for each gene which is then used for boxplot
```{r}
create_boxplotU <- function(gene){
  
  # U-CLL
  exprMat.DMSO <- counts_dfDMSO_U[rownames(counts_dfDMSO_U) == gene,]
  exprMat.Ibr <- counts_dfIbr_U[rownames(counts_dfIbr_U) == gene,]
  exprMat.Duv <- counts_dfDuv_U[rownames(counts_dfDuv_U) == gene,]
  patID1 <- colnames(counts_dfDMSO_U)
  patID2 <- colnames(counts_dfIbr_U)
  patID3 <- colnames(counts_dfDuv_U)
  trDMSO <- rep("DMSO",times=length(exprMat.DMSO))
  trIbr <- rep("Ibrutinib",times=length(exprMat.Ibr))
  trDuv <- rep("Duvelisib",times=length(exprMat.Duv))

  plotTab_U <- tibble(expression = c(exprMat.DMSO, exprMat.Ibr, exprMat.Duv),
                      treatment = c(trDMSO, trIbr, trDuv),
                      patID = c(patID1, patID2, patID3))
  plotTab_U$expression <- as.numeric(plotTab_U$expression)
  return(plotTab_U)
}

create_boxplotM <- function(gene){

  # M-CLL
  exprMat.DMSO <- counts_dfDMSO_M[rownames(counts_dfDMSO_M) == gene,]
  exprMat.Ibr <- counts_dfIbr_M[rownames(counts_dfIbr_M) == gene,]
  exprMat.Duv <- counts_dfDuv_M[rownames(counts_dfDuv_M) == gene,]
  patID1 <- colnames(counts_dfDMSO_M)
  patID2 <- colnames(counts_dfIbr_M)
  patID3 <- colnames(counts_dfDuv_M)
  trDMSO <- rep("DMSO",times=length(exprMat.DMSO))
  trIbr <- rep("Ibrutinib",times=length(exprMat.Ibr))
  trDuv <- rep("Duvelisib",times=length(exprMat.Duv))

  plotTab_M <- tibble(expression = c(exprMat.DMSO, exprMat.Ibr, exprMat.Duv),
                      treatment = c(trDMSO, trIbr, trDuv),
                      patID = c(patID1, patID2, patID3))
  plotTab_M$expression <- as.numeric(plotTab_M$expression)
  return(plotTab_M)
}
```

Function for boxplots
```{r}
colors_drugs <- c(DMSO_U="#FCB500", Duvelisib_U="#00D6D6", Ibrutinib_U="#DE02DE",
                  DMSO_M="#BD8300", Duvelisib_M="#0C8989", Ibrutinib_M="#6E006E")

drugs_order <- c("DMSO_U", "Duvelisib_U", "Ibrutinib_U",
                   "DMSO_M", "Duvelisib_M", "Ibrutinib_M")

plot_boxplot <- function(gene, plotTabU, plotTabM){
  
  tabU <- plotTabU[plotTabU$patID != "row_median",]
  tabM <- plotTabM[plotTabM$patID != "row_median",]

  # Add U or M to distinguish the data frames
  tabU$treatment <- paste(tabU$treatment, "_U", sep="")
  tabM$treatment <- paste(tabM$treatment, "_M", sep="")
  tabM$patID <- paste(tabM$patID, "_M", sep="")

  # Combine both data frames
  tabAll <- rbind(tabU, tabM)

  # Reorder treatments
  tabAll <- within(tabAll, treatment <- 
                     factor(treatment,levels=drugs_order))

  plot <- ggplot(tabAll, aes(x=treatment, y=expression, fill=treatment)) +
    geom_boxplot() +
    geom_line(aes(group=patID), position=position_dodge(0.2),
              linetype="dotted", col="grey50") +
    geom_point(aes(fill=treatment, group=patID), size=2,
               shape=21, position=position_dodge(0.2)) +
    ylab("norm. expression") +
    theme(legend.position = "none", axis.title.x=element_blank()) +
    ggtitle(paste(gene, "expression differences", sep=" ")) +
    scale_fill_manual(values=colors_drugs)

  return(plot)
}
```

Test with one gene
```{r}
plotTab_U <- create_boxplotU("JAK2")
plotTab_M <- create_boxplotM("JAK2")
plot_boxplot("JAK2", plotTab_U, plotTab_M)
```

In the boxplots we can visualize the differences between U-CLL and M-CLL, but also between DMSO, Ibrutinib and Duvelisib. 
```{r, eval=FALSE}
# Somehow saving during a loop does not work. 
# (the PDF files are created correctly, e.g. 386kb,
# but then at the end of the loop the file is shrunken to 4kb)

for(n in seq_len(10)){
  
  # Create one plot including six boxplots per gene
  plot_list <- lapply(gene_list_pathways[[n]], function(gene) {
    if(gene %in% rownames(counts_dfDMSO_U)){
      plotTab_U <- create_boxplotU(gene)
      plotTab_M <- create_boxplotM(gene)
      plot <- plot_boxplot(gene, plotTab_U, plotTab_M)
    }
  })

  # Generate characteristics for pdf file
  pathway <- names(gene_list_pathways)[n]
  pathway_save <- str_replace_all(pathway,"[-/ ]","_")
  pathway_save <- str_replace(pathway_save,"&","and")
  height <- 3.8 * ceiling(lengths(gene_list_pathways)[n] / 2)

  # Save all plots for one pathway in one PDF
  pdf(file=sprintf("./output/boxplots_DuvVsIbrpatID_%s.pdf", pathway_save),
      title=pathway, width=13, height=height)
  plot_grid(plotlist=plot_list, ncol=2)
  dev.off()
}
```

# Heatmap

For this heatmap the most distinct genes between Ibrutinib and Duvelisib are used. These are the genes considered as differentially expressed between Duvelisib and Ibrutinib with an adjusted p-value below 0.25 (25% FDR) and a log-fold change larger than 0.2 are used as input.

```{r}
padjusted <- 0.25
lfc <- 0.2

# Filter data frame
gene_list_df <- resTab %>%
  dplyr::filter(padj <= padjusted,
         LFC > lfc | LFC < -lfc) %>%
  dplyr::select(Ensembl, symbol, padj)
gene_list_df$treatment <- "Duvelisib"

# Number of genes used for pathway enrichment
n_genes <- pull(gene_list_df, Ensembl)
length(n_genes)
```

Preparations for heatmap annotations
```{r}
ddsTr <- ddsTr[,!is.na(ddsTr$IGHV)]
patAnno <- as.data.frame(colData(ddsTr))

# Define annotations
annoCol <- patAnno %>%
  dplyr::select(patID, trisomy12, IGHV, TP53, FSC.SSC, treatment)
annoCol$trisomy12 <- as.character(annoCol$trisomy12)
annoCol$TP53 <- as.character(annoCol$TP53)
annoCol$IGHV <- as.character(annoCol$IGHV)
annoCol$trisomy12[annoCol$trisomy12 == 0] <- "wt"
annoCol$trisomy12[annoCol$trisomy12 == 1] <- "m"
annoCol$TP53[annoCol$TP53 == 0] <- "wt"
annoCol$TP53[annoCol$TP53 == 1] <- "m"
annoCol$IGHV[annoCol$IGHV == 0] <- "U"
annoCol$IGHV[annoCol$IGHV == 1] <- "M"

# Define annotation colors
color_anno = list(
  treatment = c(Duvelisib="#4A72A6", Ibrutinib="#C70000"),
  #batch = c(pilot="#F8F417", batch1="#B5E222", batch2="#76EE3D", batch3="#07D256", batch4="#0A9C43"),
  IGHV = c(U="#ECB3EE", M="#A201B5"),
  TP53 = c(wt="#D5B97B", m="#B07900"),
  trisomy12 = c(wt="#7BF6F5", m="#08B8B7"))

# Define fill colors
color_fill <- colorRampPalette( rev(brewer.pal(9,"RdBu")) )(255)
```

## Before patient adjustment

Extract and subset normalized expression matrix
```{r}
exprMat <- assay(ddsTr)
exprMatsub <- exprMat[rownames(exprMat) %in% n_genes,]

# Use gene symbols instead of Ensembl IDs
gene_conv <- as.data.frame(rownames(exprMatsub))
colnames(gene_conv) <- "Ensembl"
gene_conv$symbol <- cluster_df[match(gene_conv$Ensembl, cluster_df$Ensembl),]$symbol

rownames(exprMatsub) <- gene_conv$symbol
```

Show heatmap colored with normalized counts
```{r, fig.width=11, fig.height=10}
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)

pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=12,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=3,
         main = "Heatmap of top DE genes Duv vs Ibr (without patient correction)")
```
The samples cluster by patient Identifiers.

## After patient adjustment

Extract and subset normalized expression matrix
```{r}
# Remove patient effect
exprMat <- limma::removeBatchEffect(assay(ddsTr), batch=factor(ddsTr$patID))
exprMatsub <- exprMat[rownames(exprMat) %in% n_genes,]
rownames(exprMatsub) <- gene_conv$symbol
```

Show heatmap colored with normalized counts
```{r, fig.width=11, fig.height=10}
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)

pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=12,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=3,
         main = "Heatmap of top DE genes Duv vs Ibr (after patient correction)")
```
After adjusting the patient effect, the columns cluster automatically by treatment (Duvelisib and Ibrutinib), and to some extend by IGHV status. Some genes have a very distinct gene expression in U-CLL.

## Define clustering of columns

Additionally to the clustering of columns by treatment, we force the columns to cluster by IGHV status within each treatment.

```{r}
# Sort data frame by treatment and IGHV mutation status
#annoCol <- annoCol[order(annoCol$treatment, annoCol$IGHV,
#                         decreasing = TRUE),]

Ibr_UCLL_start <- c("smp231", "smp367", "smp79", "smp1093", "smp538", "smp344", "smp191", "smp593", "smp800", "smp139", "smp387")
Ibr_UCLL_all <- rownames(annoCol[annoCol$treatment == "Ibrutinib" & annoCol$IGHV == "U",])
Ibr_UCLL_end <- setdiff(Ibr_UCLL_all,Ibr_UCLL_start)
Ibr_UCLL <- c(Ibr_UCLL_start, Ibr_UCLL_end)

Ibr_MCLL_start <- c("smp222", "smp377", "smp680", "smp831")
Ibr_MCLL_all <- rownames(annoCol[annoCol$treatment == "Ibrutinib" & annoCol$IGHV == "M",])
Ibr_MCLL_end <- setdiff(Ibr_MCLL_all,Ibr_MCLL_start)
Ibr_MCLL <- c(Ibr_MCLL_start, Ibr_MCLL_end)

Duv_UCLL_start <- c("smp232", "smp368", "smp80", "smp1094", "smp539", "smp345", "smp192", "smp594", "smp801", "smp140", "smp388")
Duv_UCLL_all <- rownames(annoCol[annoCol$treatment == "Duvelisib" & annoCol$IGHV == "U",])
Duv_UCLL_end <- setdiff(Duv_UCLL_all,Duv_UCLL_start)
Duv_UCLL <- c(Duv_UCLL_start, Duv_UCLL_end)

Duv_MCLL_start <- c("smp223", "smp378", "smp681", "smp832")
Duv_MCLL_all <- rownames(annoCol[annoCol$treatment == "Duvelisib" & annoCol$IGHV == "M",])
Duv_MCLL_end <- setdiff(Duv_MCLL_all,Duv_MCLL_start)
Duv_MCLL <- c(Duv_MCLL_start, Duv_MCLL_end)

rowOrder <- c(Ibr_UCLL,Ibr_MCLL,Duv_UCLL,Duv_MCLL)

exprMatsub <- exprMatsub[,rowOrder]
```

Show heatmap colored with normalized counts
```{r, fig.width=11, fig.height=10}
pheatmap(exprMatsub, cluster_cols=FALSE, cluster_rows=TRUE,
         color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, fontsize=12,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=3,
         main = "Heatmap of top DE genes Duv vs Ibr (after patient correction, forced order of columns)")
```
Based on this heatmap the differences between Duvelisib and Ibrutinib are slightly higher in patients with U-CLL. A reason could be that the BCR signalling is more dominant in U-CLL and thus inhibition of targets in this pathway has stronger effects on the transcriptomic landscape.


```{r, fig.width=11, fig.height=10, eval=FALSE}
library(Pigengene)
exprMattrans <- t(exprMatsub)
annoColsub <- dplyr::select(annoCol, c(treatment,IGHV))
pheatmap.type(Data=exprMattrans, annRow=annoColsub)
```


# Pathway activity with Progeny

First, we need to import some support functions.
```{r}
source("/Users/carolinelohoff/Documents/drugseq/data/support_functions.R")
source("/Users/carolinelohoff/Documents/drugseq/data/assignPROGENyScores.r")
source("/Users/carolinelohoff/Documents/drugseq/data/generateTFList.r")
source("/Users/carolinelohoff/Documents/drugseq/data/carnival_visNetwork.r")
```


In this section, we estimate the pathway activity from transcriptomics data using [PROGENy](https://github.com/saezlab/progeny).

Conventional pathway analysis methods rely on the gene expression of the pathway members. However, this approach overlooks the effect of post-translational modifications and only captures very specific experimental conditions. To overcome these limitations, PROGENy (Pathway RespOnsive GENes) estimates the activity of relevant signaling pathways based on consensus gene signatures obtained from perturbation experiments (Schubert et al. 2018).

As input we need a normalized counts matrix with gene symbols as row names and samples as columns. 
Next, we need a data frame with samples in one column and conditions in the other column. 
The last input is a matrix with gene symbols as row names and one column showing the moderated t-statistic. This is the ratio of the M-value to its standard error. This has the same interpretation as an ordinary t-statistic except that the standard errors have been moderated across genes, effectively borrowing information from the ensemble of genes to aid with inference about each individual gene.
As an alternative we use the Wald test statistic which is used for hypothesis testing in DESeq2 when comparing two groups. The Wald test is a test of hypothesis usually performed on parameters that have been estimated by maximum likelihood, such as each gene's model coefficient (LFC) derived using parameters like dispersion which were estimated using maximum likelihood.
```{r}
# Normalized counts matrix with samples form Duvelisib and Ibrutinib
ddsTr.vst <- vst(ddsTr)
exprMat <- assay(ddsTr.vst)
gene_conv <- as.data.frame(rownames(exprMat))
colnames(gene_conv) <- "Ensembl"
gene_conv$symbol <- resTab[match(gene_conv$Ensembl, resTab$Ensembl),]$symbol
rownames(exprMat) <- gene_conv$symbol

sample <- paste0(patAnno[colnames(exprMat),]$patID,"_",
                     patAnno[colnames(exprMat),]$treatment)
colnames(exprMat) <- sample

# Design data frame
condition <- rep(c("Ibrutinib", "Duvelisib"), length(sample)/2)
design_df <- data.frame(sample, condition)
design_df <- design_df[order(design_df$condition),]

exprMat <- exprMat[,design_df$sample]

# Results of DE
resTabc <- resTabc[!duplicated(resTabc$symbol),]
deResult <- resTabc %>%
  remove_rownames() %>%
  column_to_rownames(var="symbol") %>%
  dplyr::select(stat) %>%
  dplyr::rename(t = stat)
deResult <- as.matrix(deResult)
```

We first compute Progeny scores for every sample using the normalised counts in the expression matrix. To do this, we use the 200 most responsive genes per pathway.
```{r}
PathwayActivity <- progeny(exprMat,scale=TRUE,
                           organism="Human",top=200)
PathwayActivity_vec <- as.vector(PathwayActivity)
```

Show results in a heatmap
```{r, fig.width=15, fig.height=6}
paletteLength <- 100
myColor <- colorRampPalette(
  c("darkblue", "whitesmoke","indianred"))(paletteLength)

progenyBreaks <- c(seq(min(PathwayActivity_vec), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(PathwayActivity_vec)/paletteLength, 
    max(PathwayActivity_vec), 
    length.out=floor(paletteLength/2)))

progeny_hmap <- pheatmap(t(PathwayActivity), fontsize=14, 
    fontsize_row = 12, fontsize_col = 4, 
    color=myColor, breaks = progenyBreaks, 
    main = "PROGENy result with 200 most responsive genes per pathway", angle_col = 45,
    treeheight_col = 0,  border_color = NA,
    cluster_rows = T, cluster_cols = T)
```

Now, we run an enrichment analysis using a competitive permutation approach to assess the significance of the pathway activity. We end up with Normalised Enrichment Scores (NES) for each pathway.
```{r}
# Run PROGENy
PathwayActivityZscore <- progeny(deResult, 
    scale=TRUE, organism="Human", top=200, perm=10000, z_scores=TRUE) %>%
    t()
colnames(PathwayActivityZscore) <- "NES"

# Convert result to data frame
PathwayActivityZscore_df <- as.data.frame(PathwayActivityZscore) %>% 
  rownames_to_column(var = "Pathway") %>%
  dplyr::arrange(NES) %>%
  dplyr::mutate(Pathway = factor(Pathway))

# Plot NES
ggplot(PathwayActivityZscore_df,
       aes(x = reorder(Pathway, NES), y = NES)) + 
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
The JAK/STAT pathway is the most downregulated pathway upon the perturbation that we are studying (Duvelisib gene expression versus Ibrutinib). The normalized enrochment score is much lower than for all other pathways. Hypoxia is the most active pathway in Duvelisib treated cells in comparison to Ibrutinib treated CLL cells.

We can therefore visualise the JAK/STAT most responsive genes (progeny weights) along with their statistics values to interpret the results. In the scatterplot, we can see the genes that are contributing the most to the pathway enrichment.
```{r}
progMatrix <- getModel("Human", top=200) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

deResult_df <- deResult %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scatPlots <- progeny::progenyScatter(df = deResult_df, 
    weight_matrix = progMatrix, 
    statName = "stat_values", verbose = FALSE)

# Show plot
plot(scatPlots[[1]]$`JAK-STAT`)
plot(scatPlots[[1]]$`EGFR`)
plot(scatPlots[[1]]$`Hypoxia`)
```

Progeny results can be used as an optional input for CARNIVAL. CARNIVAL sets weights based on PROGENy scores in each pathway-related node in order to find more relevant solutions. We therefore run PROGENy again with slightly different parameters, setting z_scores = FALSE so that PROGENy returns pathway activity values between 1 and -1, rather than converting them to Z-Scores.
```{r}
PROGENyCARNIVALinput <- progeny(deResult, 
    scale=TRUE, organism="Human", top=200, perm=10000, z_scores=FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway")

colnames(PROGENyCARNIVALinput)[2] <- "score"
```

# Transcription factor activity with Dorothea

Using [DoRothEA](https://saezlab.github.io/dorothea/) transcription factor (TF) activities can be estimated from transcriptomics data.
DoRothEA is a comprehensive resource containing a curated collection of TFs and their transcriptional targets. The set of genes regulated by a specific TF is known as a regulon. DoRothEA’s regulons were gathered from different types of evidence. Each TF-target interaction is defined by a confidence level based on the volume of supporting evidence. The confidence levels range from A (highest confidence) to E (lowest confidence) (Garcia-Alonso et al. 2019)

DoRothEA regulons are usually coupled with the statistical method VIPER (Alvarez et al. 2016). In this context, TF activities are computed based on the mRNA expression levels of its targets. We therefore can consider TF activity as a proxy of a given transcriptional state.

We start with loading Dorothea regulons. Thereby, we can select interactions with confidence level A, B and C.
```{r}
data(dorothea_hs, package = "dorothea")
regulons <- dorothea_hs %>%
  dplyr::filter(confidence %in% c("A", "B","C"))
```

Note that for DoRothEA, we proceed the other way around than for PROGENy. We have many TFs, so we cannot clearly visualize all of them in the same heatmap. That is why we first compute a TF activity enrichment analysis using the statistics from the differential expression analysis. This will allow us to select the TFs whose activity varies with the conditions under study.
Viper performs Virtual Inference of Protein-activity by Enriched Regulon analysis. 

It is important to set the parameter "eset.filter" to FALSE. In this case, we set the minimum size of regulons to the number we give as input.
It is strongly recommend to check ?viper to set the parameters that best fit your needs.
```{r, results=FALSE}
tf_Activities_stat <- dorothea::run_viper(deResult, regulons,
    options =  list(minsize = 10, eset.filter = FALSE, 
    cores = 1, verbose = TRUE, nes = TRUE))
```

We now display the top 25 normalized enrichment scores (NES) for the TFs in a bar plot.
```{r}
tf_Activities_stat_top25 <- tf_Activities_stat %>%
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::rename(NES = "t") %>%
    dplyr::top_n(25, wt = abs(NES)) %>%
    dplyr::arrange(NES) %>% 
    dplyr::mutate(GeneID = factor(GeneID))

ggplot(tf_Activities_stat_top25,
       aes(x = reorder(GeneID, NES), y = NES)) + 
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Transcription Factors")
```

To interpret the results, we can look at the expression of targets of one of the most deregulated TFs, such as STAT2.
```{r}
resTabmod <- resTabc %>%
  dplyr::select(c(symbol, baseMean, LFC, stat, pvalue, padj)) %>%
  dplyr::rename(ID = symbol,
         AveExpr = baseMean,
         logFC = LFC,
         t = stat,
         P.value = pvalue,
         adj.P.val = padj)
rownames(resTabmod) <- resTabmod$ID
resTabmod <- resTabmod[, c(1, 3, 2, 4, 5, 6)]

# STAT2
targets_STAT2 <- regulons$target[regulons$tf == "STAT2"]
volcano_nice(as.data.frame(resTabmod[resTabmod$ID %in% targets_STAT2,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,
    nlabels = 20, label = TRUE, straight = FALSE)

# IRF9
targets_IRF9 <- regulons$target[regulons$tf == "IRF9"]
volcano_nice(as.data.frame(resTabmod[resTabmod$ID %in% targets_IRF9,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,
    nlabels = 10, label = TRUE, straight = FALSE)
```
Most of the targets of STAT2 have a lower gene expression in Duvelisib than in Ibrutinib.

The TF activity enrichment results provided by Viper are used as an input for CARNIVAL. CARNIVAL tries to infer the most likely upstream signaling events leading to the current TF activity results.
```{r}
DoRothEACARNIVALinput <- tf_Activities_stat %>%
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "TF") 
```

We now compute TF activities per sample using the normalised counts.
```{r, results=FALSE}
tf_Activities_counts_Dorothea <- 
    dorothea::run_viper(exprMat, regulons,
    options =  list(minsize = 10, eset.filter = FALSE, 
    cores = 1, verbose = TRUE, method = c("scale")))

tf_activities_counts_top25 <- tf_Activities_counts_Dorothea %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::filter(GeneID %in% tf_Activities_stat_top25$GeneID) %>%
    column_to_rownames(var = "GeneID") %>%
    as.matrix()
tf_activities_counts_vec <- as.vector(tf_activities_counts_top25)
```

We display the results of the previous 25 TFs in a Heatmap.
```{r, fig.width=15, fig.height=6}
paletteLength <- 100
myColor <-colorRampPalette(
  c("darkblue", "whitesmoke","indianred"))(paletteLength)

dorotheaBreaks <- c(seq(min(tf_activities_counts_vec), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(tf_activities_counts_vec)/paletteLength, 
    max(tf_activities_counts_vec), 
    length.out=floor(paletteLength/2)))

dorothea_hmap <- pheatmap(tf_activities_counts_top25,
    fontsize=14, fontsize_row=12, fontsize_col=4, 
    color=myColor, breaks=dorotheaBreaks,
    main="Dorothea result of top 25 transcription factors",
    angle_col=45, treeheight_col=0,  border_color=NA,
    cluster_rows=T, cluster_cols=T)
```

# Network reconstruction with CARNIVAL

CARNIVAL (CAusal Reasoning for Network identification using Integer VALue programming) is a method for the identification of upstream regulatory signalling pathways from downstream gene expression (GEX) (Liu, Trairatphisan, Gjerga et al. 2019). The aim of CARNIVAL is to identify a subset of interactions from a prior knowledge network, a network that represents potential regulated pathways linking known or potential targets of perturbation, to active transcription factors derived from GEX data.

CARNIVAL is used based on the transcription factor (TF) activity derived from transcriptomics data using DoRothEA, and the prior knowledge network obtained from Omnipath, a literature curated mammalian signaling pathway resource (Türei et al 2016).
In order to help CARNIVAL to find a solution faster, we can also use PROGENy (Schubert et al. 2018) scores to infer the score of the representative genes for each of the calculated pathways.

## Getting the scaffold network from Omnipath
Before running CARNIVAL, we need to create or upload a scaffold network. This will be “the map” that the ILP algorithm will follow to find the causal network. We use Omnipath to obtain the signed and directed interactions from all the available resources. CARNIVAL requires this information in a sif table (node1, interaction, node2) format, therefore we use the consensus columns of direction (consensus_direction) and sign (consensus_stimulation and consensus_inhibition) to extract it.

The query returns 0/1 as logic status of being a stimulation or an inhibition reaction. Thus, this output is reformulated as 1/-1 to indicate stimulation or inhibition, respectively. We can keep either the interactions that are consistent, or both alternatives (e.g. A 1 B; A -1 B). In this example, we keep the consistent ones.

The identifiers are from UniProt.
```{r, eval=FALSE}
omniR <- read.table("~/drugseq/data/Omnipath_interactions.txt",
                    header=TRUE)
```

```{r}
omniR <- OmnipathR::import_omnipath_interactions(
  organism = 9606, # human
  datasets = c('omnipath', 'pathwayextra', 'kinaseextra'))
```

```{r}
omniR <- import_all_interactions(
  resources = NULL,
  organism = 9606,
  dorothea_levels = c("A", "B"),
  exclude = NULL,
  fields = NULL,
  default_fields = TRUE,
  references_by_resource = TRUE
)
```

Filter interactions
```{r}
# Keep only signed and directed interactions
omnipath_sd <- omniR %>%
  dplyr::filter(consensus_direction == 1 &
                  (consensus_stimulation == 1 | 
                     consensus_inhibition == 1))
  
# changing 0/1 criteria in consensus_stimulation/inhibition to -1/1
omnipath_sd$consensus_stimulation[which(omnipath_sd$consensus_stimulation == 0)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 1)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 0)] = 1

# check consistency on consensus sign and select only those in a SIF format
cols <- c('source_genesymbol', 'consensus_stimulation',
          'consensus_inhibition', 'target_genesymbol')
sif <- omnipath_sd[,cols] %>%
      dplyr::filter(consensus_stimulation==consensus_inhibition) %>%
      unique.data.frame()

# Remove stimulation col and rename remaining cols
sif$consensus_stimulation <- NULL
colnames(sif) <- c('source', 'interaction', 'target')

# Remove complexes
nrow(sif)
sif <- sif %>% 
  dplyr::filter(!grepl('_', source)) %>%
  dplyr::filter(!grepl('_', target))
nrow(sif)

#save SIF
#write_tsv(sif, file="~/Documents/Batch4_knit/omnipath_carnival.tsv")
```

## Convert TF and pathway activities for CARNIVAL

Rearrange the input files for CARNIVAL
```{r}
### Dorothea for CARNIVAL
tf_activities_df <- data.frame(DoRothEACARNIVALinput, stringsAsFactors=F)
rownames(tf_activities_df) <- DoRothEACARNIVALinput$TF
tf_activities_df$TF <- NULL
tfList_Carnival = generateTFList(tf_activities_df,
                                 top=50, access_idx=1)

### Progeny for CARNIVAL  (Map UniProt ids to gene symbols)

# Load mapping list UniProtIDs -> gene symbols
load("/Users/carolinelohoff/Documents/drugseq/data/progenyMembers.RData")  

pathway_activity_df <- data.frame(PROGENyCARNIVALinput, stringsAsFactors=F)
rownames(pathway_activity_df) <- pathway_activity_df$Pathway
pathway_activity_df$Pathway <- NULL
pathwayList_Carnival = assignPROGENyScores(progeny = t(pathway_activity_df), 
                                            progenyMembers=progenyMembers, 
                                            id = "gene", 
                                            access_idx=1)
```

## Running CARNIVAL

CARNIVAL has been developed to find the causal link between the activities of the transcription factors (TFs) and the ‘perturbed’ nodes. We have to provide 2 main inputs and 2 optional inputs:

measObj: The TFs’ activities (like the ones we have obtained from DoRothEA)
inputObj: The ‘perturbed’ nodes we want that CARNIVAL connects with the activity of TFs. There are 3 ways of using it:
Give the name and sign of the selected nodes;
Give the name only, so the algorithm will select the sign that best fit the models,
Give NULL as value will create a “Perturbation” node that will try both signs for all ‘initial’ nodes of the given network ( netObj ).
netObj: The network that will serve as map to connect the TFs’ activities ( measObj ) and the perturbed nodes ( inputObj )
Although it is not required, a fourth object called weightObj can be also given. This object gives values ranged from -1 to 1 for a set of nodes of the network. The aim of weightObj is helping the solver to find optimal solutions faster.

In the present example, we use assign as perturbation nodes all the “initial” nodes (option 2), and as weightObj the PROGENy scores assigned to the most representative genes of the calculated pathways.

Preparations
```{r}
# get initial nodes
iniMTX <- setdiff(sif$source, sif$target)
iniciators <- data.frame(matrix(data = NaN, nrow = 1,
                                ncol = length(iniMTX)),
                         stringsAsFactors = F)
colnames(iniciators) <- iniMTX
iniciators_df <- data.frame(iniMTX)

tf_activities_vec <- tf_activities_df$t
names(tf_activities_vec) <- rownames(tf_activities_df)

pathway_activity_vec <- pathway_activity_df$score
names(pathway_activity_vec) <- rownames(pathway_activity_df)
```

Run Carnival
```{r, eval=FALSE}
carnival_result <- 
  runCARNIVAL(inputObj = NULL,  # iniciators_df or iniciators (perturbed nodes (optional))
  measObj = tf_activities_vec,  # TF activities from Dorothea (required)
  netObj = sif,                 # PKN from OmniPath (required)
  weightObj = pathway_activity_vec, # pathway scores (optional)
  solverPath = "/Applications/CPLEX_Studio_Community221/cplex/bin/x86-64_osx/cplex", 
  solver = "cplex",
  timelimit=7200,
  mipGAP=0,
  poolrelGAP=0,
  dir_name="/Users/carolinelohoff/Documents/R")
```
Problem with saving occurs because Carnival adds two // at the end of given path...

# DecoupleR

decoupleR needs a matrix (mat) of any molecular readouts (gene expression, logFC, p-values, etc.) and a network that relates target features (genes, proteins, etc.) to “source” biological entities (pathways, transcription factors, molecular processes, etc.). 
```{r}
mat <- exprMat
network <- sif[, c(1, 3, 2)]
network <- dplyr::rename(network,
                  mor = interaction)
# Remove repeated edges from network
repEdges <- network %>%
  group_by(.data$source, .data$target) %>%
  filter(n()>1)
repEdges_all <-rbind(network,repEdges)
network <- repEdges_all[!duplicated(repEdges_all,fromLast = FALSE)
                         &!duplicated(repEdges_all,fromLast = TRUE),] 
```

Remove colinear covariables in network
```{r, eval=FALSE}
cor <- decoupleR::check_corr(network)
```


## Univariate Linear Model
```{r, fig.width=11, fig.height=10, eval=FALSE}
res_ulm <- run_ulm(mat, network)

# Transform to matrix
mat_ulm <- res_ulm %>%
  filter(statistic=='ulm') %>%
  pivot_wider_profile(id_cols = source,
                      names_from = condition, 
                      values_from = score) %>%
  as.matrix()

pheatmap(mat_ulm, cluster_rows = F, cluster_cols = F,
         cellwidth = 15, cellheight = 40)
```

## Multiple models
```{r, fig.width=11, fig.height=10, eval=FALSE}
res_decouple <- decouple(mat, network,
                         minsize = 1)

# Transform to matrix
mat_consensus <- res_decouple %>%
  filter(statistic=='consensus') %>%
  pivot_wider_profile(id_cols = source,
                      names_from = condition, 
                      values_from = score) %>%
  as.matrix()

pheatmap(mat_consensus, cluster_rows = F, cluster_cols = F,
         cellwidth = 15, cellheight = 40)
```


# Session Info Details
```{r, echo=FALSE, eval=TRUE}
sessionInfo()
```
