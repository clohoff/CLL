---
title: "DE of treatment and genotype of all batches, pre-processed with STAR + HTSeq"
author: "Caroline Lohoff"
date: "April 26 2022"
output:
  BiocStyle::html_document:
    toc_float: true
---

# Description
In this script a differential expression analysis is performed which considers the different drug treatments and a genotype, such as TP53 mutational status, trisomy12 or IGHV status, while correcting for the variance in the data set due to patient effects. 
In order to compare the treatments with DMSO and additionally consider the genotype, a nested design is chosen for DESeq2.
Design formula: TP53 + TP53:patIDgroup + TP53:treatment
IGHV + IGHV:patIDgroup + IGHV:treatment
trisomy12 + trisomy12:patIDgroup + trisomy12:treatment (for Ibr and Duv, we assume that trisomy 12 and 19 enhance BCR signalling due to the results from the MOFA analysis. Bruch and Giles et all identified trisomy 12 as an amplifier of drug responses to microenvironmental stimuli, mediated by the transcription factors Spi-B and PU.1, [see paper](https://www.biorxiv.org/content/10.1101/2021.07.23.453514v2.full))
In other words we have an experiment with individual patients grouped by TP53 mutational status, where we seek to test the group-specific effect of a treatment, while controlling for individual effects. The individuals are nested within the groups: a patient can only be in one of the groups, although each individual has one or more observations across conditions.
A detailed description of this design can be viewed in the [DESeq2 vignette](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#group-specific-condition-effects-individuals-nested-within-groups).

The aim is to predict the effectiveness of Ibrutinib, Duvelisib and Nutlin on patients grouped by IGHV status, TP53 mutation and trisomy12. So far, these biomarkers can aid prognostication, but may also be capable of predicting the efficacy of various treatment strategies in subgroups of patients. In an [interesting review](https://www.frontiersin.org/articles/10.3389/fonc.2021.780085/full) the treatment approaches to CLL with high-risk molecular features are discussed. In this review the TP53 status has no impact on Ibrutinib treatment after first-line treatment with fludarabine monotherapy (F) or fludarabine and cyclophosphamide (FC). But they show an impressive efficacy of Ibrutinib in R/R CLL with TP53 aberrations. Several trials have also demonstrated a high efficacy of ibrutinib in R/R U-CLL.

# Load libraries and set options

Set global options
```{r setup, include=FALSE, cache = FALSE}
knitr::opts_knit$set(root.dir = "~/Documents/R/drugseq_test")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

Load libraries
```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(tidyverse)
  library(RColorBrewer)
  library(pheatmap)
  library(clusterProfiler)
  library(enrichplot)
  library(cowplot)
  library(org.Hs.eg.db)
  library(annotate)
  library(ggvenn)
  library(BiocParallel)
})
register(MulticoreParam(2))
```

Set global ggplot variables
```{r}
theme_set(theme_bw() + theme(axis.text = element_text(size=12), 
                             axis.title = element_text(size=16),
                             legend.title = element_text(size=16),
                             legend.text = element_text(size=14),
                             plot.title = element_text(size=18,
                                                       hjust=0.5,face="bold")))
# Define color palette
cp <- c("#2CB902", "#FD7306", "#FF1EBE", "#0137A4", "#C8C701")
```

# Load data and add annotations
```{r}
# Load dds data set containing 1106 samples and count matrix
load("./output/ddsDrug_htseq_batchPilot1c234_20220426.RData")

# Load meta data including genotyping info
load("./data/patmeta_210324.RData")

# Add columns to DESeq object using patient meta data
col_vec <- c("diagnosis", "gender", "Methylation_Cluster", "trisomy12", "NOTCH1", "TP53")
ddsDrug@colData@listData <- lapply(col_vec, function(n) {
  ddsDrug[[n]] <- patMeta[match(ddsDrug$patID, patMeta$Patient.ID), n]
}) %>% bind_cols() %>% sjmisc::add_columns(ddsDrug@colData@listData)

names(ddsDrug@colData@listData)[names(ddsDrug@colData@listData) == "Methylation_Cluster"] <- "Methylation"
ddsDrug$IGHVpat <- patMeta[match(ddsDrug$patID, patMeta$Patient.ID),]$IGHV.status
ddsDrug$IGHV <- ifelse(is.na(ddsDrug$IGHV), ddsDrug$IGHVpat, ddsDrug$IGHV)

# Add meta data to the samples from the pilot batch
ddsDrug$diagnosis[ddsDrug$batch == "pilot"] <- "CLL" 
ddsDrug$trisomy12[ddsDrug$batch == "pilot"] <- 0
ddsDrug$NOTCH1[ddsDrug$batch == "pilot"] <- 0
ddsDrug$TP53[ddsDrug$batch == "pilot"] <- 0
ddsDrug$IGHV[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1095", "PID1222")] <- "U"
ddsDrug$IGHV[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1177", "PID1210")] <- "M"
ddsDrug$gender[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1095", "PID1222")] <- "f"
ddsDrug$gender[ddsDrug$batch == "pilot" & ddsDrug$patID %in% c("PID1177", "PID1210")] <- "m"

# Rename IGHV status from 'U' and 'M' to 0 and 1
ddsDrug$IGHV[ddsDrug$IGHV == "U"] <- 0
ddsDrug$IGHV[ddsDrug$IGHV == "M"] <- 1
ddsDrug$IGHV <- as.factor(ddsDrug$IGHV)

# Remove columns
ddsDrug$IGHVpat <- NULL
ddsDrug$fileName <- NULL
ddsDrug$expID <- NULL
ddsDrug$expBatch <- NULL
ddsDrug$time <- NULL
ddsDrug$Barcode <- NULL
ddsDrug$RIN <- NULL

dim(ddsDrug)
```

Filter genes, counts and diagnosis
```{r}
# Only use protein coding genes and include only CLL samples in analysis
ddsAll <- ddsDrug[rowData(ddsDrug)$biotype == "protein_coding" & !rowData(ddsDrug)$symbol %in% c(NA, ""),
                  ddsDrug$diagnosis == "CLL" & ddsDrug$treatment != "Baseline" & ddsDrug$Replicate == 1]

# Show chromosomes
table(rowData(ddsAll)$chromosome)

# Remove all mitochondrial and artificial chromosomes
ddsAll <- ddsAll[rowData(ddsAll)$chromosome %in% c(1:22,"X","Y")]

# Remove genes on Y chromosome which could introduce some bias
ddsAll <- ddsAll[rowData(ddsAll)$chromosome != "Y"]
# ddsAll <- ddsAll[!rowData(ddsAll)$chromosome %in% c("X","Y")]
table(rowData(ddsAll)$chromosome)

# Keep only genes with a minimum of 10 counts in any sample
keep_counts <- apply(counts(ddsAll), 1, function(x) any(x >= 10))
ddsAll <- ddsAll[keep_counts,]

# Remove patients without DMSO sample, since no comparison is possible
patIDs <- unique(ddsAll$patID)
vec <- c()

for(id in patIDs){
  if(ddsDrug$treatment[ddsDrug$patID == id] == "DMSO"){
    vec <- append(vec, id)
  }
}
removepat <- setdiff(patIDs, vec)
ddsAll <- ddsAll[, !ddsAll$patID %in% removepat]

# Replace spaces in treatment names
ddsAll$treatment <- str_replace_all(ddsAll$treatment,"[- ]","_")

# Extract count matrix
counts_df <- as.data.frame(ddsAll@assays@data@listData$counts)

dim(ddsAll)
```

A new column is added to the ddsAll object in which the viability of the DMSO sample after 48 hours of incubation is added to all samples from one patient. The information about the viability of the treatment samples after 48 hours is still available in the original column.
```{r}
ddsAll$FSC.SSC.DMSO <- 0
patIDs <- data.frame(ddsAll@colData@listData) %>%
  distinct(patID) %>% pull(patID)

for(id in patIDs){
  viability <- ddsAll$FSC.SSC[ddsAll$patID == id & ddsAll$treatment == "DMSO"]
  ddsAll$FSC.SSC.DMSO[ddsAll$patID == id] <- viability
}
```

Variance stabilization transformation of the raw data
```{r vst}
ddsAllnorm <- varianceStabilizingTransformation(ddsAll)
```

Compare expression level of TP53 between wild type and mutated
```{r}
TP53 <- ddsAllnorm["ENSG00000141510",] 
TP53_df <- as.data.frame(TP53@assays@data@listData) %>%
  pivot_longer(everything(), names_to = "Sample")

TP53_df$Condition <- ddsAll[match(TP53_df$Sample, ddsAll$ID),]$TP53
TP53_df$Treatment <- ddsAll[match(TP53_df$Sample, ddsAll$ID),]$treatment

TP53_df %>%
  group_by(Condition) %>%
  ggplot(aes(x=Condition, y=value, col=Condition)) +
  geom_boxplot() +
  ylab("Normalized counts") +
  ggtitle("Gene expression overview TP53") 
```
Samples with TP53 wild type have an overall higher expression rate than samples with mutated TP53.

Compare variance introduced by different treatments
```{r, fig.height=4, fig.width=12}
TP53_df %>%
  group_by(Treatment) %>%
  ggplot(aes(x=Treatment, y=value, col=Treatment)) +
  geom_violin() +
  ylab("Normalized counts") +
  ggtitle("Variance of TP53 expression across treatments") +
  geom_jitter(height = 0, width = 0.1)
```
The variance of TP53 expression introduced by the different treatments is depicted in the figure above.
The different variances are reasons why the differential expression analysis should be run separately on the individual treatments. Otherwise the differences in counts are less important for drugs with smaller TP53 counts variance and could lead to a bias in the number of DE genes.
The PCA plot colored by treatment also shows the differences between the drugs.

## RNA-Seq count distribution

To test whether the expression of genes between two or more groups is significantly different, we need an appropriate statistical model, which is determined by the count distribution. When we plot the distribution of counts for a single sample, we can visualize key features of RNA-Seq count data, including a large proportion of genes with low raw counts and many genes with zero counts. In comparison, a few genes have a high expression, as there is no maximum limit for reads per gene in RNA-Seq data. If there is no expression variation between biological replicates, the Poisson distribution is frequently used.
If the biological variation cannot be modeled by the Poisson distribution, a negative binomial model can serve as a good model choice for DESeq2.
```{r}
ggplot(counts_df) +
  geom_histogram(aes(x=smp659), stat="bin", bins=100) +
  labs(x="Raw expression counts", y="Number of genes",
       title="Distribution of raw counts within one sample")
```

## Statistics (variance and mean)

The aim of DE analysis is to determine whether a gene’s mean expression between sample groups is different given the variation within groups. This is determined by testing the probability of the log2 fold changes between groups being significantly different from zero:

Log2(mean(treatment)/mean(control)) = 0

To explore the variation in the data, we will observe the variance in gene expression relative to the mean. Variance is the square of the standard deviation, representing how far away the expression of the individual samples are from the means. For RNA-Seq data the variance is expected to increase with the genes mean expression.
```{r}
DMSO <- ddsAll[, ddsAll$treatment == "DMSO"]
DMSO_samples <- DMSO$ID

# Calculate mean for each gene of DMSO samples
mean_counts <- apply(counts_df[, DMSO_samples], 1, mean)
# Calculate variance for each gene of DMSO samples
variance_counts <- apply(counts_df[, DMSO_samples], 1, var)
# Create a data frame
statistics_df <- data.frame(mean_counts, variance_counts)
# Plot the statistics
ggplot(statistics_df) +
  geom_point(aes(x=mean_counts, y=variance_counts)) +
               scale_x_log10() +
               scale_y_log10() +
               labs(x="Mean counts per gene", y="Variance per gene") +
               ggtitle("Statistics for DMSO samples")
```
Usually, this plot shows a diagonal for RNA-Seq data. Also, the range for variance is greater for lower mean counts than for higher mean counts.


# Differential expression using DESeq2

Differential expression analysis of genomic data types uses linear models to determine the size and direction of the changes in gene expression.

## Preparations of input data
Subset dds object into different objects with one treatment and DMSO
```{r}
allTreat <- data.frame(ddsAll@colData) %>% filter(treatment != "DMSO") %>%
  distinct(treatment) %>% pull(treatment)

ddstr <- lapply(allTreat, function(tr) {
  patIDtr <- unique(ddsAll$patID[ddsAll$treatment == tr])
  ddsdrug <- ddsAll[, ddsAll$treatment %in% c(tr, "DMSO") & ddsAll$patID %in% patIDtr]
})
names(ddstr) <- allTreat
```


### Example of nested design for Ibrutinib and TP53

For this design we need the columns patient ID, treatment and TP53 mutational status.
```{r}
df <- as.data.frame(ddstr$Ibrutinib@colData)[c("patID","treatment","TP53")]
head(df, 10)
```
We have two groups of TP53 status, 0 and 1, representing TP53 wild type and TP53 mutation. 

Next, we want to find out how many patients are in each group. 
```{r}
TP0 <- unique(df$patID[df$TP53 == 0])
TP0
length(TP0)
TP1 <- unique(df$patID[df$TP53 == 1])
TP1
length(TP1)
```
71 patients have a TP53 wild type, whereas 17 distinct individuals have a TP53 mutation.  
For each individual, we have samples treated with Ibrutinib and DMSO as control. 

This type of design can be analyzed by DESeq2 but requires a bit of refactoring in order to fit the model terms. If we try to analyze with a formula such as, ~ patID + TP53 + treatment + TP53:treatment or ~ patID + TP53*treatment, we will obtain an error, as the effect for the genotype is a linear combination of the individual patients.
However, the following steps allow for an analysis of TP53-specific treatment effects, while controlling for differences in patients.
We add a column patIDgroup which distinguishes the individuals nested within a TP53 group. Thus, we redefine the patient IDs for TP53 wt and TP53 mutation, respectively.
```{r}
ddstr$Ibrutinib$patIDgroup <- NA

for(pat in TP0){
  ddstr$Ibrutinib$patIDgroup[ddstr$Ibrutinib$patID == pat] <- which(TP0 == pat)
}

for(pat in TP1){
  ddstr$Ibrutinib$patIDgroup[ddstr$Ibrutinib$patID == pat] <- which(TP1 == pat)
}
ddstr$Ibrutinib$patIDgroup <- factor(ddstr$Ibrutinib$patIDgroup)

df2 <- as.data.frame(ddstr$Ibrutinib@colData)[c("patID","treatment","TP53","patIDgroup")]
head(df2, 10)
```

Now we can reassign our DESeqDataSet using a design of ~ TP53 + TP53:patIDgroup + TP53:treatment, before we call DESeq. This new design will result in the following model matrix:
```{r}
patAnno <- data.frame(colData(ddstr$Ibrutinib)) %>% dplyr::select(TP53, trisomy12, IGHV, treatment, patIDgroup) %>%
  mutate(treatment = str_replace_all(treatment,"[- ]","_")) %>%
  mutate(treatment = factor(treatment,
                            levels = c("DMSO",setdiff(unique(treatment),"DMSO"))))
designMat <- model.matrix(~ TP53 + TP53:patIDgroup + TP53:treatment, patAnno)

head(designMat, 6)
dim(designMat)
```

As the two TP53 groups have different sizes (71 patients vs 17 patients), some columns in the design matrix have only zeros, such as TP531:patIDgroup20. These columns need to be removed. 
```{r}
all.zero <- apply(designMat, 2, function(x) all(x==0))
remove <- which(all.zero)
designMat <- designMat[,-remove]
dim(designMat)
```
Now, we have prepared the data set for Ibrutinib and TP53 comparison as well as the design matrix. 

### Create the design matrix for each treatment
The same procedure as applied above for a design with Ibrutinib and TP53 has to be applied for all treatments and genotypes of interest.

```{r, include=TRUE, eval=FALSE}
genotype <- c("TP53", "trisomy12", "IGHV")

for(geno in genotype){
  for(drug in allTreat){
    
    # Extract dds object
    dds <- ddstr[[drug]]
    
    # Exclude rows with a non-specified genotype (NA)
    if(geno == "IGHV"){
      dds <- dds[, dds$IGHV %in% c(0, 1)]
    }
    
    # Extract number of patients for each genotype group
    g0 <- unique(dds$patID[dds[[geno]] == 0])
    g1 <- unique(dds$patID[dds[[geno]] == 1])
    
    # Add new column to rename the patients
    dds$patIDgroup <- NA

    for(pat in g0){
      dds$patIDgroup[dds$patID == pat] <- which(g0 == pat)
    }
    for(pat in g1){
      dds$patIDgroup[dds$patID == pat] <- which(g1 == pat)
    }
    dds$patIDgroup <- factor(dds$patIDgroup)
    
    # Create data frame to set differences
    patAnno <- data.frame(colData(dds)) %>%
      dplyr::select(TP53, trisomy12, IGHV, treatment, patIDgroup) %>%
      mutate(treatment = factor(treatment, levels = c("DMSO",setdiff(unique(treatment),"DMSO"))))
    
    # Create design matrix
    if(geno == "TP53"){
      designMat <- model.matrix(~ TP53 + TP53:patIDgroup + TP53:treatment, patAnno)
    }else if(geno == "trisomy12"){
      designMat <- model.matrix(~ trisomy12 + trisomy12:patIDgroup + trisomy12:treatment, patAnno)
    }else{
      designMat <- model.matrix(~ IGHV + IGHV:patIDgroup + IGHV:treatment, patAnno)
    }
    
    # Remove empty columns in design matrix
    all.zero <- apply(designMat, 2, function(x) all(x==0))
    remove <- which(all.zero)
    if(length(remove) > 0){
      designMat <- designMat[,-remove]
    }
    print(dim(designMat))

    # Add the design matrix to dds object
    design(dds) <- designMat

    # Save dds object
    save(dds, file = sprintf("./DE/dds_%s_%s_allbatches_STAR_20220318.RData", geno, drug))
  }
}
```

### Analyse design matrix with CoefExplainer

[CoefExplainer](https://github.com/const-ae/CoefExplainer) by Constantin helps to understand how the coefficients of a categorical linear model can be interpreted. In this example we model the expression of TP53 with a nested design formula which compares Ibrutinib with DMSO and also takes into account the patient variation and the mutation status of TP53.
```{r}
# devtools::install_github("const-ae/CoefExplainer")
library(CoefExplainer)

# Create small example data set with two patients per TP53 mutation status
smp <- c("smp6", "smp7", "smp16", "smp17", "smp149", "smp150", "smp190", "smp191")
patAnno_small <- patAnno[rownames(patAnno) %in% smp, ]
patAnno_small$patIDgroup <- as.factor(as.numeric(patAnno_small$patIDgroup))

# Add column for TP53 expression (counts)
#counts_df$smp191[counts_df$Ensembl == "ENSG00000141510"]
geneTP53 <- c(193, 200, 424, 70, 69, 37, 82, 51)
patAnno_small$TP53expression <- geneTP53

# Parse the nested design formula for our linear model to CoefExplainer
coefExplFit <- CoefExplainer(patAnno_small, TP53expression ~ TP53 + TP53:patIDgroup + TP53:treatment)
```

Beeswarm plot for each group:
This plot shows for each group, how the coefficients are combined to arrive at the prediction for that group (blue line) and how that line compares against the true group mean (red line).
```{r, fig.height=5, fig.width=15}
plotModel(coefExplFit)
```
Look at the underlying model matrix
```{r, fig.height=5, fig.width=15}
plotModelMatrix(coefExplFit)
```

Look at the magnitude of each coefficient
```{r, fig.height=5, fig.width=15}
plotCoef(coefExplFit)
```

For a better insight, we use another gene of interest, the notch receptor 1 (ENSG00000148400). This single-pass transmembrane receptor plays a role in a variety of developmental processes by controlling cell fate decisions. NOTCH1 has emerged as the most commonly mutated gene in CLL at diagnosis, and NOTCH1 mutations are associated with poor outcomes ([Rosati et. al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6030253/)).
```{r, fig.height=5, fig.width=15}
geneNOTCH1 <- c(78, 107, 181, 7, 111, 34, 32, 12)
patAnno_small$NOTCH1expression <- geneNOTCH1
coefExplFit <- CoefExplainer(patAnno_small, NOTCH1expression ~ TP53 + TP53:patIDgroup + TP53:treatment)
plotCoef(coefExplFit)
```
When we compare the NOTCH1 expression between groups, the mutational status of TP53 is less important. Instead, the difference between treatment (Ibrutinib) and DMSO is more significant. 

NOTCH1 with 4 patients per mutation group
```{r, fig.height=5, fig.width=15, eval=FALSE, include=FALSE}
smp2 <- c(smp, "smp1004", "smp1005", "smp790", "smp791", "smp799", "smp800", "smp639", "smp640")
patAnno_small2 <- patAnno[rownames(patAnno) %in% smp2, ]
patAnno_small2$patIDgroup <- NULL

# Add column for NOTCH1 expression (counts)
geneNOTCH1 <- c(78, 107, 181, 7, 111, 34, 32, 12, 47, 11, 17, 4, 20, 4, 18, 33)
patAnno_small2$NOTCH1expression <- geneNOTCH1
patIDgroup <- c(1, 1, 2, 2, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4)
patAnno_small2$patIDgroup <- as.factor(patIDgroup)
coefExplFit <- CoefExplainer(patAnno_small2, NOTCH1expression ~ TP53 + TP53:patIDgroup + TP53:treatment)
plotCoef(coefExplFit)
```

The covariates with the largest magnitudes should be considered for the contrast argument when extracting results with DESeq2.


## Run DESeq2

The DESeq function fits the raw counts to the negative binomial model. The final dds object contains all the information needed for performing DE testing between specific sample groups. New information such as shrunken dispersions, model coefficients, Wald test results, and gene-wise dispersions will be added to the dds object.
```{r,include=TRUE, eval=FALSE}
for(drug in allTreat){
  load(sprintf("./DE/dds_IGHV_%s_allbatches_STAR_20220318.RData", drug))
  DEres <- DESeq(dds, parallel=TRUE)
  save(DEres, file = sprintf("./DE/DEres_IGHV_%s_allbatches_STAR_20220318.RData", drug))
}
# running time: 1 hour 15 min with 2 cores

#ddsDis <- estimateDispersions(dds)
#DEres_TP53_Ibrutinib <- nbinomWaldTest(ddsAllDis, maxit=1000)
```


## Get results for TP53

Load results of individual treatments and combine all results in a list
```{r, eval=FALSE, include=TRUE}
DEres_list <- list()
for(drug in allTreat){
  load(sprintf("./DE/DEres_TP53_%s_allbatches_STAR_20220318.RData", drug))
  drug <- list(DEres)
  DEres_list <- append(DEres_list, drug)
}

DEres_list <- DEres_list[-c(1, 2)]
load("./DE/DEres_TP53_Ibrutinib_allbatches_STAR_20220318.RData")
load("./DE/DEres_TP53_Duvelisib_allbatches_STAR_20220318.RData")
DEres_listIbrDuv <- list(DEres_TP53_Ibrutinib, DEres_TP53_Duvelisib)
DEres_list <- append(DEres_listIbrDuv, DEres_list)

names_DEres <- c()
for(drug in allTreat){
  names_DEres <- append(names_DEres, sprintf("DEres_TP53_%s", drug))
}
names(DEres_list) <- names_DEres

save(DEres_list, file = "./DE/DEreslist_allTr_TP53_allbatches_STAR_20220318.RData")
```

Load list with DESeq2 results
```{r}
load("./DE/DEreslist_allTr_TP53_allbatches_STAR_20220318.RData")

# Omit any remaining rows, as these are typically genes with very small counts and little power
dim(DEres_list$DEres_TP53_Ibrutinib)
DEres_TP53_IbrutinibC <- DEres_list$DEres_TP53_Ibrutinib[which(mcols(DEres_list$DEres_TP53_Ibrutinib)$betaConv),]
dim(DEres_TP53_IbrutinibC)
length(unique(DEres_TP53_IbrutinibC$patID))

DEres_TP53_Nutlin_3aC <- DEres_list$DEres_TP53_Nutlin_3a[which(mcols(DEres_list$DEres_TP53_Nutlin_3a)$betaConv),]
DEres_TP53_DuvelisibC <- DEres_list$DEres_TP53_Duvelisib[which(mcols(DEres_list$DEres_TP53_Duvelisib)$betaConv),]
```

### Extract contrasts between groups of genotypes

In the design matrix, the terms TP530:treatmentIbrutinib and TP531:treatmentIbrutinib give the group-specific treatment effects of Ibrutinib, i.e. the Ibrutinib vs DMSO effect for group TP53 wild type samples, and likewise for group TP53 mutated samples. These terms control for all of the 88 individual patient effects. These group-specific treatment effects can be extracted using results with the name argument.

Furthermore, these two groups of TP53 can be contrasted using the contrast argument, in order to test if the treatment effect is different across groups:
```{r}
resultsNames(DEres_TP53_IbrutinibC)
resIbrutinib <- results(DEres_TP53_IbrutinibC, contrast=list("TP530.treatmentIbrutinib", "TP531.treatmentIbrutinib"), parallel=TRUE)
```

Plot distribution of LFCs
```{r}
plotMA(resIbrutinib, ylim=c(-3,3), cex=.8, main="LFC values without shrinkage")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```

When extracting the results, shrinking the log fold changes is useful for visualization and ranking of genes, without the need for arbitrary filters on low count genes.

Contrast can only be used in lfcShrink with the shrinkage estimators "normal" and "ashr". "normal" shrinks multiple coefficients simultaneously ("apeglm" does not), and "ashr" does not estimate a vector of coefficients but models estimated coefficients and their standard errors from upstream methods, e.g. DESeq2’s MLE.
"ashr" is an estimator with a fitted mixture of normals prior from the ashr package, whereas "apeglm" is an estimator using a t prior from the apeglm packages.
If "apeglm" should be used as the estimator, the design needs to be rearranged such that what was a contrast becomes its own coefficient. In this case, the dispersion does not have to be estimated again, as the designs are equivalent, up to the meaning of the coefficients. Instead, one need only run nbinomWaldTest to re-estimate MLE coefficients and then run lfcShrink specifying the coefficient of interest in resultsNames(dds).

```{r}
# Shrinkage with ashr estimator
resIbrutinibShrink <- lfcShrink(DEres_TP53_IbrutinibC, contrast=list("TP530.treatmentIbrutinib", "TP531.treatmentIbrutinib"), type="ashr", parallel=TRUE)

# Shrinkage with apeglm estimator
# design(DEres_TP53_IbrutinibC) <- model.matrix()
# DEres_TP53_IbrutinibCbinom <- nbinomWaldTest(DEres_TP53_IbrutinibC, maxit=500)
# resultsNames(DEres_TP53_IbrutinibCbinom)
# resIbrutinibShrink <- lfcShrink(DEres_TP53_IbrutinibCbinom, coef="", type="apeglm", parallel=TRUE)
```

Plot distribution of shrunken LFCs
```{r}
plotMA(resIbrutinibShrink, ylim=c(-3,3), cex=.8, main="LFC values after shrinkage")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```

Make contrasts with limma
```{r}
#contrastDuv <- limma::makeContrasts()
#resDuv <- results(DEres, contrast=as.vector(contrastDuv))
```


### Extract results for wild type and mutated TP53 separately

Extract results data frames with prior shrinkage of LFC values with apeglm estimator

```{r, include=FALSE, eval=FALSE}
### Function to shrink the results of all treatments

# Omit any remaining rows, as these are typically genes with very small counts and little power
i <- 1
allResShrink <- lapply(DEres_list, function(drug) {
  for(genotype in c("0", "1")){
    drugname <- strsplit(names(DEres_list),"[_]")[[i]][3]
    print(drugname)
    coefname <- sprintf("TP53%s.treatment%s", genotype, drugname)
    print(coefname)
    res <- lfcShrink(drug[which(mcols(drug)$betaConv),],
                     coef=coefname, type="apeglm", parallel=TRUE)
  }
  i <- i + 1
})

names_DEresShrink <- c()
for(drug in allTreat){
  for(genotype in c("wt", "m")){
    names_DEres <- append(names_DEres, sprintf("DEresShrink_TP53_%s_%s", drug, genotype))
  }
}
names(allResShrink) <- names_DEresShrink

save(allResShrink, file = "./DE/allResShrink_TP53_allbatches_STAR_20220318.RData")
```

Shrink results of Ibrutinib, Duvelisib, and Nutlin 3a
```{r, include=TRUE, eval=FALSE}
resIbrutinibShrink_wt <- lfcShrink(DEres_list$DEres_TP53_Ibrutinib[which(mcols(DEres_list$DEres_TP53_Ibrutinib)$betaConv),], coef="TP530.treatmentIbrutinib", type="apeglm", parallel=TRUE)
resIbrutinibShrink_m <- lfcShrink(DEres_list$DEres_TP53_Ibrutinib[which(mcols(DEres_list$DEres_TP53_Ibrutinib)$betaConv),], coef="TP531.treatmentIbrutinib", type="apeglm", parallel=TRUE)
                                  
resDuvelisibShrink_wt <- lfcShrink(DEres_list$DEres_TP53_Duvelisib[which(mcols(DEres_list$DEres_TP53_Duvelisib)$betaConv),], coef="TP530.treatmentDuvelisib", type="apeglm", parallel=TRUE)
resDuvelisibShrink_m <- lfcShrink(DEres_list$DEres_TP53_Duvelisib[which(mcols(DEres_list$DEres_TP53_Duvelisib)$betaConv),], coef="TP531.treatmentDuvelisib", type="apeglm", parallel=TRUE)
                                  
resNutlinShrink_wt <- lfcShrink(DEres_list$DEres_TP53_Nutlin_3a[which(mcols(DEres_list$DEres_TP53_Nutlin_3a)$betaConv),],
                                coef="TP530.treatmentNutlin_3a", type="apeglm", parallel=TRUE)
resNutlinShrink_m <- lfcShrink(DEres_list$DEres_TP53_Nutlin_3a[which(mcols(DEres_list$DEres_TP53_Nutlin_3a)$betaConv),],
                               coef="TP531.treatmentNutlin_3a", type="apeglm", parallel=TRUE)

allResShrink <- list(resIbrutinibShrink_wt, resIbrutinibShrink_m, resDuvelisibShrink_wt,
                     resDuvelisibShrink_m, resNutlinShrink_wt, resNutlinShrink_m)  

names(allResShrink) <- c("DEresShrink_TP53_Ibrutinib_wt", "DEresShrink_TP53_Ibrutinib_m",
                         "DEresShrink_TP53_Duvelisib_wt", "DEresShrink_TP53_Duvelisib_m",
                         "DEresShrink_TP53_Nutlin_wt", "DEresShrink_TP53_Nutlin_m")

save(allResShrink, file = "./DE/allResShrink_TP53_allbatches_STAR_20220318.RData")
```

Load results data frames with shrunken LFC values
```{r}
load("./DE/allResShrink_TP53_allbatches_STAR_20220318.RData")
```

Plot distribution of shrunken LFCs for wild type and mutated genotype
```{r}
plotMA(allResShrink$DEresShrink_TP53_Ibrutinib_wt, ylim=c(-3,3), cex=.8, main="Ibrutinib TP53 wild type")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

plotMA(allResShrink$DEresShrink_TP53_Ibrutinib_m, ylim=c(-3,3), cex=.8, main="Ibrutinib TP53 mutation")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```


# Focus on IGHV

## Run DESeq2
```{r, include=TRUE, eval=FALSE}
for(drug in allTreat){
  load(sprintf("./DE/dds_IGHV_%s_allbatches_STAR_20220318.RData", drug))
  DEres <- DESeq(dds, parallel=TRUE)
  save(DEres, file = sprintf("./DE/DEres_IGHV_%s_allbatches_STAR_20220318.RData", drug))
}

#for(drug in IbrDuvNut){
#  load(sprintf("./DE/dds_IGHVpatIDviabDMSO_%s_STAR_20220422.RData", drug))
#  DEres <- DESeq(dds, parallel=TRUE)
#  save(DEres, file = sprintf("./DE/DEres_IGHVpatIDviabDMSO_%s_STAR_20220422.RData", drug))
#}
```

## Load and transform results

Load DESeq results of interest and combine them to list
```{r}
IbrDuvNut <- c("Ibrutinib", "Duvelisib", "Nutlin_3a")

DEres_list <- list()
for(drug in IbrDuvNut){
  load(sprintf("./DE/DEres_IGHV_%s_allbatches_STAR_20220318.RData", drug))
  drug <- list(DEres)
  DEres_list <- append(DEres_list, drug)
}
names(DEres_list) <- IbrDuvNut
```

The results for wild type and mutated IGHV are extracted separately with prior shrinkage of LFC values using the apeglm estimator. 
```{r, include=TRUE, eval=FALSE}
resIbrShrink_wt <- lfcShrink(DEres_list$Ibrutinib[which(mcols(DEres_list$Ibrutinib)$betaConv),],
                             coef="IGHV0.treatmentIbrutinib", type="apeglm", parallel=TRUE)
resIbrShrink_m <- lfcShrink(DEres_list$Ibrutinib[which(mcols(DEres_list$Ibrutinib)$betaConv),],
                            coef="IGHV1.treatmentIbrutinib", type="apeglm", parallel=TRUE)
                                  
resDuvShrink_wt <- lfcShrink(DEres_list$Duvelisib[which(mcols(DEres_list$Duvelisib)$betaConv),],
                             coef="IGHV0.treatmentDuvelisib", type="apeglm", parallel=TRUE)
resDuvShrink_m <- lfcShrink(DEres_list$Duvelisib[which(mcols(DEres_list$Duvelisib)$betaConv),],
                            coef="IGHV1.treatmentDuvelisib", type="apeglm", parallel=TRUE)
                                  
resNutShrink_wt <- lfcShrink(DEres_list$Nutlin_3a[which(mcols(DEres_list$Nutlin_3a)$betaConv),],
                                coef="IGHV0.treatmentNutlin_3a", type="apeglm", parallel=TRUE)
resNutShrink_m <- lfcShrink(DEres_list$Nutlin_3a[which(mcols(DEres_list$Nutlin_3a)$betaConv),],
                               coef="IGHV1.treatmentNutlin_3a", type="apeglm", parallel=TRUE)

allResShrink_IGHVpatID <- list(resIbrShrink_wt, resIbrShrink_m, resDuvShrink_wt,
                     resDuvShrink_m, resNutShrink_wt, resNutShrink_m)  

names(allResShrink_IGHVpatID) <- c("Ibrutinib_wt", "Ibrutinib_m", "Duvelisib_wt",
                         "Duvelisib_m", "Nutlin_wt", "Nutlin_m")

save(allResShrink_IGHVpatID, file = "./DE/allResShrink_IGHV_IbrDuvNut_allbatches_STAR_20220318.RData")
```

Load results data frames with shrunken LFC values
```{r}
load("./DE/allResShrink_IGHV_IbrDuvNut_allbatches_STAR_20220318.RData")
```

Create results data frames from the resulting dds files with shrunken LFCs
```{r}
counter <- 0
allRes <- lapply(allResShrink_IGHVpatID, function(res) {
  counter <<- counter + 1
  resTab <- data.frame(res@listData) %>%
      mutate(treatment = sprintf("%s_IGHV%s",
                                 strsplit(names(allResShrink_IGHVpatID), "[_]")[[counter]][1],
                                 strsplit(names(allResShrink_IGHVpatID), "[_]")[[counter]][2])) %>%
      rownames_to_column(var = "Ensembl") %>%
      mutate(symbol = rowData(ddsDrug)[Ensembl,]$symbol) %>%
      mutate(chromosome = rowData(ddsDrug)[Ensembl,]$chromosome)
  names(resTab)[names(resTab) == "log2FoldChange"] <- "LFC"
  resTab_final <- resTab
})
names(allRes) <- names(allResShrink_IGHVpatID)
```

The results of the different drugs are combined to one df
```{r}
# Change names of columns by adding treatment and mutation status
colname <- c("Ibr_wt", "Ibr_m", "Duv_wt", "Duv_m", "Nut_wt", "Nut_m")
name <- 0

allRes_names <- lapply(allRes, function(df) {
  name <<- name + 1
  colnames(df) <- paste(colnames(df),colname[name],sep="_")
  df_new <- df
})
names(allRes_names) <- names(allResShrink_IGHVpatID)


# Create one df with the results of all treatments
allRes_combined <- allRes$Ibrutinib_wt %>%
  dplyr::select(Ensembl, symbol, chromosome)

coljoin <- c("Ensembl_Ibr_wt", "Ensembl_Ibr_m", "Ensembl_Duv_wt",
             "Ensembl_Duv_m", "Ensembl_Nut_wt", "Ensembl_Nut_m")
enumerator <- 0

for(df in allRes_names){
  enumerator <- enumerator + 1
  allRes_combined <- full_join(allRes_combined, df,
                             by=c("Ensembl" = coljoin[enumerator]), keep=FALSE)
}
```


## Visualize DE results

In this section we explore how well our data fit the model.

### Dispersion of results before shrinkage

A measure of the variance for a given mean is described by a metric called dispersion. The DESeq2 model uses dispersion to assess the variability expression when modelling the counts. The dispersion is indirectly related to the mean and the variance of the data using the following formula, with alpha denoting the dispersion and mu the mean:

Dispersion formula: Var = mu + alpha * mu^2

An increase in variance will increase dispersion, while an increase in mean will decrease dispersion. Thus, for any two genes with the same mean expression a difference in dispersion will be caused by a difference in variance.

The dispersion estimates are used to model the raw counts. If the dispersions do not follow the assumptions made by DESeq2, then the variation in the data could be poorly estimated and the DE results could be less accurate.
```{r}
# Ibrutinib
DEres_IbrutinibC <- DEres_list$Ibrutinib[which(mcols(DEres_list$Ibrutinib)$betaConv),]
plotDispEsts(DEres_IbrutinibC)

# Duvelisib
DEres_DuvelisibC <- DEres_list$Duvelisib[which(mcols(DEres_list$Duvelisib)$betaConv),]
plotDispEsts(DEres_DuvelisibC)

# Nutlin
DEres_NutlinC <- DEres_list$Nutlin[which(mcols(DEres_list$Nutlin)$betaConv),]
plotDispEsts(DEres_NutlinC)
```
This plot looks quite good, as we expect the dispersion values to decrease with increasing mean and that they cluster around the fitted maximum likelihood line. Larger numbers of replicates can estimate the mean and variation more accurately, so yield less shrinkage.

Each black dot is a gene with an associated mean and dispersion value. The red line represents information used across all genes to determine the most likely estimates of dispersion for a given gene expression value. Genes with inaccurately small estimates of variation could yield many false positive genes identified as DE although there are not. Therefore, the original gene-wise dispersion estimates (black dots) are shrunken toward the curve to yield more accurate estimates of dispersion (blue dots), which are used to model the counts for determining the DE genes. Extremely high dispersion values surrounded by blue circles are not shrunken due to the likelihood that the gene may have higher variability than other genes for biological or technical reasons. Reducing the variation could result in false positives.

### Distribution of shrunken LFCs

Plot distribution of shrunken LFCs for wild type and mutated genotype
```{r}
# Ibrutinib
plotMA(allResShrink_IGHVpatID$Ibrutinib_wt, ylim=c(-3,3),
             cex=.8, main="Ibrutinib IGHV wild type")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

plotMA(allResShrink_IGHVpatID$Ibrutinib_m, ylim=c(-3,3),
             cex=.8, main="Ibrutinib IGHV mutation")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

# Duvelisib
plotMA(allResShrink_IGHVpatID$Duvelisib_wt, ylim=c(-3,3),
             cex=.8, main="Duvelisib IGHV wild type")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

plotMA(allResShrink_IGHVpatID$Duvelisib_m, ylim=c(-3,3),
             cex=.8, main="Duvelisib IGHV mutation")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

# Nutlin
plotMA(allResShrink_IGHVpatID$Nutlin_wt, ylim=c(-3,3),
             cex=.8, main="Nutlin IGHV wild type")
abline(h=c(-1,1), col="dodgerblue", lwd=2)

plotMA(allResShrink_IGHVpatID$Nutlin_m, ylim=c(-3,3),
             cex=.8, main="Nutlin IGHV mutation")
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```

### P-value histogram

```{r, fig.height=6, fig.width=7}
hist_list <- lapply(allRes, function(res) {
 ggplot(res, aes(x=pvalue)) +
    geom_histogram(fill="lightblue", color="black",binwidth=0.025) +
  geom_vline(xintercept=0.05,color="red",linetype="longdash") +
  facet_wrap(~ treatment) +
  scale_x_continuous(breaks = seq(0,1,by=0.2)) +
  ylab("# of genes") +
  theme(plot.title = element_text(face="bold",hjust=0.5))
})

plot_grid(plotlist=hist_list, ncol=2)
```

### Number of significant DE genes 

#### Preparation
Function for creating a df with significant up- or downregulated genes
```{r}
object_names <- names(allRes)

sig_genes_df <- function(gle, fdr){
  # Create new df with number of sign. genes for each treatment
  genes_df <- setNames(data.frame(matrix(ncol = 2, nrow = 0)),
                         c("treatment", "sig_genes"))
  compare <- match.fun(gle)

  for(df in allRes){
    n_genes <- filter(df, compare(LFC,0) & padj < fdr) %>% 
      summarise(n=length(Ensembl)) %>% pull(n)
    tr <- unique(df$treatment)
    tr <- gsub('IGHV', '', tr)
  
    new_row <- c(tr, n_genes)
    genes_df[nrow(genes_df) + 1, ] <- new_row
  }
  genes_df$sig_genes <- as.numeric(genes_df$sig_genes)
  genes_df$treatment <- factor(genes_df$treatment,
                                 levels = object_names)
  return(genes_df)
}
```

Function for plotting number of significant genes for each treatment
```{r}
sigDEgenes <- function(df, title){
  plot <- ggplot(df, aes(x=treatment, y=sig_genes)) +
    geom_bar(stat = "identity", color="black", fill="#0C3C9F") +
    theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1)) +
    ylab("# significant DE genes") +
    theme(axis.title.x = element_blank()) +
    ggtitle(title) +
    geom_text(aes(label=sig_genes),vjust=-0.25,size=3)
  return(plot)
}
```

#### 5% FDR
```{r,fig.height=4, fig.width=8}
# Upregulated
sig_genes_df_up <- sig_genes_df(gle=">", fdr=0.05)
genes_5FDRup <- sigDEgenes(df=sig_genes_df_up, title="5% FDR upregulated")

# Downregulated
sig_genes_df_down <- sig_genes_df(gle="<", fdr=0.05)
genes_5FDRdown <- sigDEgenes(df=sig_genes_df_down, title="5% FDR downregulated")

plot_grid(genes_5FDRup, genes_5FDRdown, ncol=2)
```

#### 10% FDR
```{r,fig.height=4, fig.width=8}
# Upregulated
sig_genes_df_up <- sig_genes_df(gle=">", fdr=0.1)
genes_10FDRup <- sigDEgenes(df=sig_genes_df_up, title="10% FDR upregulated")

# Downregulated
sig_genes_df_down <- sig_genes_df(gle="<", fdr=0.1)
genes_10FDRdown <- sigDEgenes(df=sig_genes_df_down, title="10% FDR downregulated")

plot_grid(genes_10FDRup, genes_10FDRdown, ncol=2)
```

#### 25% FDR
```{r,fig.height=4, fig.width=8}
# Upregulated
sig_genes_df_up <- sig_genes_df(gle=">", fdr=0.25)
genes_25FDRup <- sigDEgenes(df=sig_genes_df_up, title="25% FDR upregulated")

# Downregulated
sig_genes_df_down <- sig_genes_df(gle="<", fdr=0.25)
genes_25FDRdown <- sigDEgenes(df=sig_genes_df_down, title="25% FDR downregulated")

plot_grid(genes_25FDRup, genes_25FDRdown, ncol=2)
```

 
### Table of significant associations of all treatments and IGHV

```{r}
allRes_combined %>%
  dplyr::select(Ensembl, symbol, chromosome,
                LFC_Ibr_wt, padj_Ibr_wt, LFC_Ibr_m, padj_Ibr_m,
                LFC_Duv_wt, padj_Duv_wt, LFC_Duv_m, padj_Duv_m,
                LFC_Nut_wt, padj_Nut_wt, LFC_Nut_m, padj_Nut_m) %>%
  mutate_if(is.numeric, formatC, digits=2) %>%
  DT::datatable()
```

### Volcano plots

Function for creating volcano plot
```{r}
volcano <- function(res, title){
  plot <- ggplot(res, aes(x=LFC, y=-log10(padj))) +
    geom_vline(xintercept = 0, color="black", linetype="solid", size=0.25) +
    geom_hline(yintercept = -log10(0.01), color="darkgrey", linetype="dashed") +
    geom_hline(yintercept = -log10(0.10), color="darkgrey", linetype="dashed") +
    geom_vline(xintercept = 1, color="darkgrey", linetype="dashed") +
    geom_vline(xintercept =-1, color="darkgrey", linetype="dashed") +
    geom_point(data=res[res$LFC >= 0 & res$padj <= 0.1,],
              color="firebrick3", size=0.9) +
    geom_point(data=res[res$LFC <= 0 & res$padj <= 0.1,],
              color="navy", size=0.9) +
    geom_point(data=res[res$padj >= 0.1,], color="darkgrey", size=0.9) +
    geom_label(data=res[res$padj <= 0.001,], aes(label=symbol),
               label.size=NA, fill=NA, size=2, nudge_y=c(log10(2))) +
    ggtitle(title) +
    theme(plot.title = element_text(hjust=0.5, face="bold"))
  return(plot)
}
```

Remove genes with non-calculated adjusted p-values
```{r}
allRes_na<- lapply(allRes, function(df) {
  df <- df[!is.na(df$padj),]
  })
names(allRes_na) <- object_names
```

Show volcano plot for all conditions
```{r, fig.height=18, fig.width=12}
p1 <- volcano(allRes_na$Ibrutinib_wt, title="Ibrutinib IGHV wt")
p2 <- volcano(allRes_na$Ibrutinib_m, title="Ibrutinib IGHV m")
p3 <- volcano(allRes_na$Duvelisib_wt, title="Duvelisib IGHV wt")
p4 <- volcano(allRes_na$Duvelisib_wt, title="Duvelisib IGHV m")
p5 <- volcano(allRes_na$Nutlin_wt, title="Nutlin IGHV wt")
p6 <- volcano(allRes_na$Nutlin_wt, title="Nutlin IGHV m")

plot_grid(p1, p2, p3, p4, p5, p6, ncol=2)
```


### Heatmap

#### Preparations

Extract the top genes of the individual results. 
First, we filter the log fold change values and then, we select the smallest p-values.
```{r}
ngenes <- 500
lfc <- 1.5

# All significant genes
top_genes <- lapply(object_names, function(tr) {
  allRes_sub <- allRes[[tr]] %>%
    filter(LFC < -lfc | LFC > lfc) %>%
    arrange(padj) %>% slice(1:ngenes)
  vec <- allRes_sub$Ensembl
  })
all_top_genes <- unique(unlist(top_genes))

# Upregulated significant genes
top_genes_up <- lapply(object_names, function(tr) {
  allRes_sub <- allRes[[tr]] %>%
    filter(LFC > lfc) %>%
    arrange(padj) %>% slice(1:ngenes)
  vec <- allRes_sub$Ensembl
  })
all_top_genes_up <- unique(unlist(top_genes_up))

# Downregulated significant genes
top_genes_down <- lapply(object_names, function(tr) {
  allRes_sub <- allRes[[tr]] %>%
    filter(LFC < -lfc) %>%
    arrange(padj) %>% slice(1:ngenes)
  vec <- allRes_sub$Ensembl
  })
all_top_genes_down <- unique(unlist(top_genes_down))
```

Define annotations and colors
```{r}
# Define annotations
annoCol <- as.data.frame(ddsAllnorm@colData) %>%
  dplyr::select(patID, FSC.SSC, treatment, IGHV, TP53, trisomy12, batch)

annoCol$IGHV <- as.character(annoCol$IGHV)
annoCol$IGHV[annoCol$IGHV == "0"] <- "U"
annoCol$IGHV[annoCol$IGHV == "1"] <- "M"
annoCol$TP53 <- as.character(annoCol$TP53)
annoCol$TP53[annoCol$TP53 == "0"] <- "wt"
annoCol$TP53[annoCol$TP53 == "1"] <- "m"
annoCol$trisomy12 <- as.character(annoCol$trisomy12)
annoCol$trisomy12[annoCol$trisomy12 == "0"] <- "wt"
annoCol$trisomy12[annoCol$trisomy12 == "1"] <- "m"

# Define colors of annotations
color_anno = list(
  batch = c(pilot="#F8F417", batch1="#B5E222", batch2="#76EE3D", batch3="#07D256", batch4="#0A9C43"),
  trisomy12 = c(wt = "#DB86C6", m = "#9E137B"),
  TP53 = c(wt = "#F0C538", m = "#AC8400"),
  IGHV = c(U="#A4FFF4", M="#17C6B1"),
  treatment = c(DMSO="#A1A1A1", Duvelisib="#F133B7", 
                Ibrutinib="#FFE000", Nutlin_3a="#3C33F1"))

# Define fill colors of heatmap
color_fill <- colorRampPalette( rev(brewer.pal(9,"RdBu")) )(255)
```

#### Normalized counts

Prepare expression matrix
```{r}
# Extract normalized expression matrix
exprMat.norm <- assay(ddsAllnorm)

# Subset normalized expression matrix by using only top genes
exprMatsub <- exprMat.norm[rownames(exprMat.norm) %in% all_top_genes,]

# Subset columns by only using treatments of interest
IbrDuvNutDMSO <- c("DMSO", "Ibrutinib", "Duvelisib", "Nutlin_3a")
smp <- unique(ddsAll$ID[ddsAll$treatment %in% IbrDuvNutDMSO])
exprMatsub <- exprMatsub[,colnames(exprMatsub) %in% smp]

# Scale expression matrix
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)
```

Show heatmap colored with normalized counts
```{r, fig.width=16, fig.height=13}
pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=13,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=2,
         main = sprintf("Heatmap of top %s genes of IGHV m and wt (Ibrutinib, Duvelisib, Nutlin)", ngenes))
```

#### DMSO viability-adjusted counts

As we see in the previous heatmap, viability (FSC.SSC) is the major source of variation between the samples.
Since we are interested in the differences between the treatments and not in the differences due to viability, we can adjust the visual representation in the heatmap by correcting for viability. Therefore, we correct the normalized gene expression counts matrix for DMSO viability with the "removeBatchEffect" function from limma.
```{r}
exprMat.DMSOnorm <- limma::removeBatchEffect(exprMat.norm,
                                             batch=factor(ddsAll$FSC.SSC.DMSO))
# mode(exprMat.DMSOnorm) <- "integer"
```

***Question***: Adjust for DMSO viability before or after subsetting the norm. counts matrix to only contain DMSO, Ibrutinib, Duvelisib and Nutlin?

#### All significant genes
```{r}
# Subset normalized expression matrix by using only top genes
exprMatsub <- exprMat.DMSOnorm[rownames(exprMat.DMSOnorm) %in% all_top_genes,]

# Subset columns of expression matrix
smp <- unique(ddsAll$ID[ddsAll$treatment %in% IbrDuvNutDMSO])
exprMatsub <- exprMatsub[,colnames(exprMatsub) %in% smp]

# Scale expression matrix
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)
```

```{r, fig.width=16, fig.height=13}
pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=13,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=2,
         main = sprintf("Heatmap of top %s genes of IGHV m and wt (Ibrutinib, Duvelisib, Nutlin)", ngenes))
```

#### Upregulated significant genes
```{r}
# Subset normalized expression matrix by using only top genes
exprMatsub <- exprMat.DMSOnorm[rownames(exprMat.DMSOnorm) %in% all_top_genes_up,]

# Subset columns of expression matrix
smp <- unique(ddsAll$ID[ddsAll$treatment %in% IbrDuvNutDMSO])
exprMatsub <- exprMatsub[,colnames(exprMatsub) %in% smp]

# Scale expression matrix
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)
```

```{r, fig.width=16, fig.height=13}
pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=13,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=2,
         main = sprintf("Heatmap of top %s genes of IGHV m and wt (Ibrutinib, Duvelisib, Nutlin)", ngenes))
```

#### Downregulated significant genes
```{r}
# Subset normalized expression matrix by using only top genes
exprMatsub <- exprMat.DMSOnorm[rownames(exprMat.DMSOnorm) %in% all_top_genes_down,]

# Subset columns of expression matrix
smp <- unique(ddsAll$ID[ddsAll$treatment %in% IbrDuvNutDMSO])
exprMatsub <- exprMatsub[,colnames(exprMatsub) %in% smp]

# Scale expression matrix
exprMatsub <- jyluMisc::mscale(exprMatsub, censor=2)
```

```{r, fig.width=16, fig.height=9}
pheatmap(exprMatsub, color = color_fill, annotation_col = annoCol,
         annotation_colors = color_anno, clustering_method = "ward.D2", fontsize=13,
         labels_col = paste0(patAnno[colnames(exprMatsub),]$patID,"_",
                             patAnno[colnames(exprMatsub),]$treatment),
         show_rownames=T, fontsize_row=3, show_colnames=T, fontsize_col=2,
         main = sprintf("Heatmap of top %s genes of IGHV m and wt (Ibrutinib, Duvelisib, Nutlin)", ngenes))
```


# Pathway Enrichment Analysis



# Session Info Details
```{r, echo=FALSE, eval=TRUE}
sessionInfo()
```
